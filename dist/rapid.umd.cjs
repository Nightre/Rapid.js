"use strict";var t,e,r,s,i,n;exports.LineTextureMode=void 0,(t=exports.LineTextureMode||(exports.LineTextureMode={})).STRETCH="stretch",t.REPEAT="repeat",exports.TextureWrapMode=void 0,(e=exports.TextureWrapMode||(exports.TextureWrapMode={})).REPEAT="repeat",e.CLAMP="clamp",e.MIRROR="mirror",exports.MaskType=void 0,(r=exports.MaskType||(exports.MaskType={})).Include="normal",r.Exclude="inverse",exports.TilemapShape=void 0,(s=exports.TilemapShape||(exports.TilemapShape={})).SQUARE="square",s.ISOMETRIC="isometric",exports.ShaderType=void 0,(i=exports.ShaderType||(exports.ShaderType={})).SPRITE="sprite",i.GRAPHIC="graphic",exports.BlendMode=void 0,(n=exports.BlendMode||(exports.BlendMode={})).Additive="additive",n.Subtractive="subtractive",n.Mix="mix";var a;exports.ArrayType=void 0,(a=exports.ArrayType||(exports.ArrayType={}))[a.Float32=0]="Float32",a[a.Uint32=1]="Uint32",a[a.Uint16=2]="Uint16";class o{constructor(t){this.usedElemNum=0,this.maxElemNum=512,this.bytePerElem=this.getArrayType(t).BYTES_PER_ELEMENT,this.arrayType=t,this.arraybuffer=new ArrayBuffer(this.maxElemNum*this.bytePerElem),this.updateTypedArray()}getArrayType(t){switch(t){case exports.ArrayType.Float32:return Float32Array;case exports.ArrayType.Uint32:return Uint32Array;case exports.ArrayType.Uint16:return Uint16Array}}updateTypedArray(){switch(this.uint32=new Uint32Array(this.arraybuffer),this.float32=new Float32Array(this.arraybuffer),this.uint16=new Uint16Array(this.arraybuffer),this.arrayType){case exports.ArrayType.Float32:this.typedArray=this.float32;break;case exports.ArrayType.Uint32:this.typedArray=this.uint32;break;case exports.ArrayType.Uint16:this.typedArray=this.uint16}}clear(){this.usedElemNum=0}resize(t=0){if((t+=this.usedElemNum)>this.maxElemNum){for(;t>this.maxElemNum;)this.maxElemNum<<=1;this.setMaxSize(this.maxElemNum)}}setMaxSize(t=this.maxElemNum){const e=this.typedArray;this.maxElemNum=t,this.arraybuffer=new ArrayBuffer(t*this.bytePerElem),this.updateTypedArray(),this.typedArray.set(e)}pushUint32(t){this.uint32[this.usedElemNum++]=t}pushFloat32(t){this.float32[this.usedElemNum++]=t}pushUint16(t){this.uint16[this.usedElemNum++]=t}pop(t){this.usedElemNum-=t}getArray(t=0,e){return null==e?this.typedArray:this.typedArray.subarray(t,e)}get length(){return this.typedArray.length}}class h extends o{constructor(t,e,r=t.ARRAY_BUFFER,s=t.STATIC_DRAW){super(e),this.dirty=!0,this.webglBufferSize=0,this.gl=t,this.buffer=t.createBuffer(),this.type=r,this.usage=s}pushFloat32(t){super.pushFloat32(t),this.dirty=!0}pushUint32(t){super.pushUint32(t),this.dirty=!0}pushUint16(t){super.pushUint16(t),this.dirty=!0}bindBuffer(){this.gl.bindBuffer(this.type,this.buffer)}bufferData(){if(this.dirty){const t=this.gl;this.maxElemNum>this.webglBufferSize?(t.bufferData(this.type,this.getArray(),this.usage),this.webglBufferSize=this.maxElemNum):t.bufferSubData(this.type,0,this.getArray(0,this.usedElemNum)),this.dirty=!1}}}class u extends o{constructor(){super(exports.ArrayType.Float32)}pushMat(){const t=this.usedElemNum-6,e=this.typedArray;this.resize(6),this.pushFloat32(e[t+0]),this.pushFloat32(e[t+1]),this.pushFloat32(e[t+2]),this.pushFloat32(e[t+3]),this.pushFloat32(e[t+4]),this.pushFloat32(e[t+5])}popMat(){this.pop(6)}pushIdentity(){this.resize(6),this.pushFloat32(1),this.pushFloat32(0),this.pushFloat32(0),this.pushFloat32(1),this.pushFloat32(0),this.pushFloat32(0)}translate(t,e){if("number"!=typeof t)return this.translate(t.x,t.y);const r=this.usedElemNum-6,s=this.typedArray;s[r+4]=s[r+0]*t+s[r+2]*e+s[r+4],s[r+5]=s[r+1]*t+s[r+3]*e+s[r+5]}rotate(t){const e=this.usedElemNum-6,r=this.typedArray,s=Math.cos(t),i=Math.sin(t),n=r[e+0],a=r[e+1],o=r[e+2],h=r[e+3];r[e+0]=n*s-a*i,r[e+1]=n*i+a*s,r[e+2]=o*s-h*i,r[e+3]=o*i+h*s}scale(t,e){if("number"!=typeof t)return this.scale(t.x,t.y);e||(e=t);const r=this.usedElemNum-6,s=this.typedArray;s[r+0]=s[r+0]*t,s[r+1]=s[r+1]*t,s[r+2]=s[r+2]*e,s[r+3]=s[r+3]*e}apply(t,e){if("number"!=typeof t)return new d(...this.apply(t.x,t.y));const r=this.usedElemNum-6,s=this.typedArray;return[s[r+0]*t+s[r+2]*e+s[r+4],s[r+1]*t+s[r+3]*e+s[r+5]]}getInverse(){const t=this.usedElemNum-6,e=this.typedArray,r=e[t+0],s=e[t+1],i=e[t+2],n=e[t+3],a=e[t+4],o=e[t+5],h=r*n-s*i;return new Float32Array([n/h,-s/h,-i/h,r/h,(i*o-n*a)/h,(s*a-r*o)/h])}getTransform(){const t=this.usedElemNum-6,e=this.typedArray;return new Float32Array([e[t+0],e[t+1],e[t+2],e[t+3],e[t+4],e[t+5]])}setTransform(t){const e=this.usedElemNum-6,r=this.typedArray;r[e+0]=t[0],r[e+1]=t[1],r[e+2]=t[2],r[e+3]=t[3],r[e+4]=t[4],r[e+5]=t[5]}getGlobalPosition(){const t=this.usedElemNum-6,e=this.typedArray;return new d(e[t+4],e[t+5])}setGlobalPosition(t,e){if("number"!=typeof t)return void this.setGlobalPosition(t.x,t.y);const r=this.usedElemNum-6,s=this.typedArray;s[r+4]=t,s[r+5]=e}getGlobalRotation(){const t=this.usedElemNum-6,e=this.typedArray;return Math.atan2(e[t+1],e[t+0])}setGlobalRotation(t){const e=this.usedElemNum-6,r=this.typedArray,s=this.getGlobalScale(),i=Math.cos(t),n=Math.sin(t);r[e+0]=i*s.x,r[e+1]=n*s.x,r[e+2]=-n*s.y,r[e+3]=i*s.y}getGlobalScale(){const t=this.usedElemNum-6,e=this.typedArray,r=Math.sqrt(e[t+0]*e[t+0]+e[t+1]*e[t+1]),s=Math.sqrt(e[t+2]*e[t+2]+e[t+3]*e[t+3]);return new d(r,s)}setGlobalScale(t,e){if("number"!=typeof t)return void this.setGlobalScale(t.x,t.y);const r=this.getGlobalRotation(),s=Math.cos(r),i=Math.sin(r),n=this.usedElemNum-6,a=this.typedArray;a[n+0]=s*t,a[n+1]=i*t,a[n+2]=-i*e,a[n+3]=s*e}globalToLocal(t){const e=this.getInverse();return new d(e[0]*t.x+e[2]*t.y+e[4],e[1]*t.x+e[3]*t.y+e[5])}localToGlobal(t){return this.apply(t)}toCSSTransform(){const t=this.usedElemNum-6,e=this.typedArray;return`matrix(${e[t+0]}, ${e[t+1]}, ${e[t+2]}, ${e[t+3]}, ${e[t+4]}, ${e[t+5]})`}identity(){const t=this.usedElemNum-6,e=this.typedArray;e[t+0]=1,e[t+1]=0,e[t+2]=0,e[t+3]=1,e[t+4]=0,e[t+5]=0}applyTransform(t,e=0,r=0){(t.saveTransform??1)&&this.pushMat(),t.afterSave&&t.afterSave();const s=t.x||0,i=t.y||0;(s||i)&&this.translate(s,i),t.position&&this.translate(t.position),t.rotation&&this.rotate(t.rotation),t.scale&&this.scale(t.scale);let n=t.offsetX||0,a=t.offsetY||0;t.offset&&(n+=t.offset.x,a+=t.offset.y);const o=t.origin;return o&&("number"==typeof o?(n-=o*e,a-=o*r):(n-=o.x*e,a-=o.y*r)),{offsetX:n,offsetY:a}}applyTransformAfter(t){t.beforRestore&&t.beforRestore(),(t.restoreTransform??1)&&this.popMat()}}class l extends h{constructor(t,e,r,s){super(t,exports.ArrayType.Uint16,t.ELEMENT_ARRAY_BUFFER,t.STATIC_DRAW),this.setMaxSize(e*s);for(let t=0;t<s;t++)this.addObject(t*r);this.bindBuffer(),this.bufferData()}addObject(t){}}class c{constructor(t,e,r,s=255){this._r=t,this._g=e,this._b=r,this._a=s,this.updateUint()}get r(){return this._r}set r(t){this._r=t,this.updateUint()}get g(){return this._g}set g(t){this._g=t,this.updateUint()}get b(){return this._b}set b(t){this._b=t,this.updateUint()}get a(){return this._a}set a(t){this._a=t,this.updateUint()}updateUint(){this.uint32=(this._a<<24|this._b<<16|this._g<<8|this._r)>>>0}setRGBA(t,e,r,s){this.r=t,this.g=e,this.b=r,this.a=s,this.updateUint()}copy(t){this.setRGBA(t.r,t.g,t.b,t.a)}clone(){return new c(this._r,this._g,this._b,this._a)}equal(t){return t.r===this.r&&t.g===this.g&&t.b===this.b&&t.a===this.a}static fromHex(t){t.startsWith("#")&&(t=t.slice(1));const e=parseInt(t.slice(0,2),16),r=parseInt(t.slice(2,4),16),s=parseInt(t.slice(4,6),16);let i=255;return t.length>=8&&(i=parseInt(t.slice(6,8),16)),new c(e,r,s,i)}add(t){return new c(Math.min(this.r+t.r,255),Math.min(this.g+t.g,255),Math.min(this.b+t.b,255),Math.min(this.a+t.a,255))}subtract(t){return new c(Math.max(this.r-t.r,0),Math.max(this.g-t.g,0),Math.max(this.b-t.b,0),Math.max(this.a-t.a,0))}}c.Red=new c(255,0,0,255),c.Green=new c(0,255,0,255),c.Blue=new c(0,0,255,255),c.Yellow=new c(255,255,0,255),c.Purple=new c(128,0,128,255),c.Orange=new c(255,165,0,255),c.Pink=new c(255,192,203,255),c.Gray=new c(128,128,128,255),c.Brown=new c(139,69,19,255),c.Cyan=new c(0,255,255,255),c.Magenta=new c(255,0,255,255),c.Lime=new c(192,255,0,255),c.White=new c(255,255,255,255),c.Black=new c(0,0,0,255),c.TRANSPARENT=new c(0,0,0,0);class d{constructor(t,e){this.x=void 0!==t?t:0,this.y=void 0!==e?e:0}add(t){return new d(this.x+t.x,this.y+t.y)}subtract(t){return new d(this.x-t.x,this.y-t.y)}multiply(t){return t instanceof d?new d(this.x*t.x,this.y*t.y):new d(this.x*t,this.y*t)}divide(t){return t instanceof d?new d(this.x/t.x,this.y/t.y):new d(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}distanceTo(t){const e=this.x-t.x,r=this.y-t.y;return Math.sqrt(e*e+r*r)}clone(){return new d(this.x,this.y)}copy(t){this.x=t.x,this.y=t.y}equal(t){return t.x==this.x&&t.y==this.y}perpendicular(){const t=this.x;return this.x=-this.y,this.y=t,this}invert(){return this.x=-this.x,this.y=-this.y,this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return this.x=this.x/t||0,this.y=this.y/t||0,this}angle(){return Math.atan2(this.y,this.x)}middle(t){return new d((this.x+t.x)/2,(this.y+t.y)/2)}abs(){return new d(Math.abs(this.x),Math.abs(this.y))}floor(){return new d(Math.floor(this.x),Math.floor(this.y))}ceil(){return new d(Math.ceil(this.x),Math.ceil(this.y))}snap(t){return new d(Math.round(this.x/t)*t,Math.round(this.y/t)*t)}stringify(){return`Vec2(${this.x}, ${this.y})`}static FromArray(t){return t.map((t=>new d(t[0],t[1])))}angleBetween(t){const e=this.dot(t),r=this.length()*t.length(),s=Math.max(-1,Math.min(1,e/r));return Math.acos(s)}}d.ZERO=new d(0,0),d.ONE=new d(1,1),d.UP=new d(0,1),d.DOWN=new d(0,-1),d.LEFT=new d(-1,0),d.RIGHT=new d(1,0);class p{constructor(t){this.render=t}createLightShadowMaskPolygon(t,e,r){const s=[];t.forEach((t=>{for(let e=0;e<t.length;e++){const r=t[e],i=t[(e+1)%t.length];s.push([r,i])}})),r=r||Math.sqrt(Math.pow(this.render.width,2)+Math.pow(this.render.height,2));const i=[];return s.forEach((([t,s])=>{const n=new d(t.x-e.x,t.y-e.y),a=new d(s.x-e.x,s.y-e.y),o=s.subtract(t).perpendicular(),h=Math.abs(o.dot(n))/(o.length()*n.length())+.01,u=Math.abs(o.dot(a))/(o.length()*a.length())+.01,l=r/h,c=r/u,p=new d(n.x,n.y).normalize(),f=new d(a.x,a.y).normalize(),x=new d(t.x+p.x*l,t.y+p.y*l),g=new d(s.x+f.x*c,s.y+f.y*c);i.push([t,s,g,x])})),i}}const f=(t,e,r,s)=>{const i=[],n=s?Math.atan2(e.y,e.x):Math.atan2(-e.y,-e.x),a=Math.PI;for(let e=0;e<10;e++){const s=n+e/10*a,o=n+(e+1)/10*a,h=Math.cos(s)*r,u=Math.sin(s)*r,l=Math.cos(o)*r,c=Math.sin(o)*r;i.push(t),i.push(t.add(new d(h,u))),i.push(t.add(new d(l,c)))}return i},x=t=>{const e=t.points;if(e.length<2)return{vertices:[],uv:[]};const{normals:r,length:s}=((t,e=!1)=>{const r=[];if(t.length<2||e&&t.length<3)return{normals:r,length:0};const s=t.length;let i=0;if(e)for(let e=0;e<s;e++){const r=t[e],n=t[(e+1)%s];i+=r.distanceTo(n)}else for(let e=0;e<s-1;e++)i+=t[e].distanceTo(t[e+1]);const n=(t,e,r)=>{const s=e.subtract(t).normalize(),i=e.subtract(r).normalize(),n=i.dot(s);if(n<-.999)return{normal:s.perpendicular(),miters:1};{let t=i.add(s).normalize();s.cross(i)<0&&(t=t.multiply(-1));let e=1/Math.sqrt((1-n)/2);return{normal:t,miters:Math.min(e,4)}}};if(e){for(let e=0;e<s-1;e++){const i=0===e?t[s-2]:t[e-1],a=t[e],o=t[e+1];r.push(n(i,a,o))}r.push(r[0])}else for(let e=0;e<s;e++)if(0===e){const e=t[1].subtract(t[0]).normalize();r.push({normal:e.perpendicular(),miters:1})}else if(e===s-1){const s=t[e].subtract(t[e-1]).normalize();r.push({normal:s.perpendicular(),miters:1})}else r.push(n(t[e-1],t[e],t[e+1]));return{normals:r,length:i}})(e,t.closed),i=(t.width||1)/2,n=[],a=[],o=t.roundCap||!1,h=t.textureMode||exports.LineTextureMode.STRETCH;let u=0;const l=t.texture?.width||1;for(let t=0;t<e.length-1;t++){const o=e[t],c=r[t].normal,p=r[t].miters,f=o.add(c.multiply(p*i)),x=o.subtract(c.multiply(p*i)),g=e[t+1],m=r[t+1].normal,y=r[t+1].miters,T=g.add(m.multiply(y*i)),E=g.subtract(m.multiply(y*i)),b=o.distanceTo(g);let w=0,R=0;h===exports.LineTextureMode.STRETCH?(w=u/s,R=(u+b)/s):(w=u/l,R=w+b/l);const S=new d(w,0),A=new d(w,1),M=new d(R,0),v=new d(R,1);n.push(f),a.push(S),n.push(x),a.push(A),n.push(T),a.push(M),n.push(T),a.push(M),n.push(E),a.push(v),n.push(x),a.push(A),u+=b}if(o&&!t.closed){const t=e[0],s=r[0].normal,a=f(t,s,i,!0);n.push(...a);const o=e[e.length-1],h=r[e.length-1].normal,u=f(o,h,i,!1);n.push(...u)}return{vertices:n,uv:a}};var g="precision mediump float;\r\nvarying vec2 vRegion;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uTexture;\r\nuniform int uUseTexture;\r\n\r\nvoid main(void) {\r\n    vec4 color;\r\n    if(uUseTexture > 0){\r\n        color = texture2D(uTexture, vRegion) * vColor;\r\n    }else{\r\n        color = vColor;\r\n    }\r\n    // fragment\r\n    gl_FragColor = color;\r\n}\r\n",m="precision mediump float;\r\n\r\nattribute vec2 aPosition;\r\nattribute vec4 aColor;\r\nattribute vec2 aRegion;\r\n\r\nvarying vec4 vColor;\r\nuniform mat4 uProjectionMatrix;\r\nuniform vec4 uColor;\r\nvarying vec2 vRegion;\r\n\r\nvoid main(void) {\r\n    // vertex s\r\n    gl_Position = uProjectionMatrix * vec4(aPosition, 0.0, 1.0);\r\n    // vertex e\r\n    vColor = aColor;\r\n    vRegion = aRegion;\r\n}\r\n";const y=(t,e,r)=>{const s=t.createShader(r);if(!s)throw new Error("Unable to create webgl shader");t.shaderSource(s,e),t.compileShader(s);if(!t.getShaderParameter(s,t.COMPILE_STATUS)){const r=t.getShaderInfoLog(s);throw console.error("Shader compilation failed:",r),new Error("Unable to compile shader: "+r+e)}return s};function T(t,e,r,s=!1,i=!1,n="clamp"){const a=t.createTexture();if(!a)throw new Error("unable to create texture");let o;switch(t.bindTexture(t.TEXTURE_2D,a),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,r?t.LINEAR:t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,r?t.LINEAR:t.NEAREST),n){case"repeat":o=t.REPEAT;break;case"mirror":o=t.MIRRORED_REPEAT;break;default:o=t.CLAMP_TO_EDGE}return t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,o),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,o),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,i),s?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,null):t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),a}const E=5126;var b="precision mediump float;\r\nuniform sampler2D uTextures[%TEXTURE_NUM%];\r\n\r\nvarying vec2 vRegion;\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void) {\r\n    vec4 color;\r\n    %GET_COLOR%\r\n    // fragment\r\n    gl_FragColor = color * vColor;\r\n}",w="precision mediump float;\r\n\r\nattribute vec2 aPosition;\r\nattribute vec2 aRegion;\r\nattribute float aTextureId;\r\nattribute vec4 aColor;\r\n\r\nuniform mat4 uProjectionMatrix;\r\n\r\nvarying vec2 vRegion;\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void) {\r\n    vRegion = aRegion;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor;\r\n\r\n    // vertex s\r\n    gl_Position = uProjectionMatrix * vec4(aPosition, 0.0, 1.0);\r\n    // vertex e\r\n}";const R=[{name:"aPosition",size:2,type:E,stride:24},{name:"aRegion",size:2,type:E,stride:24,offset:2*Float32Array.BYTES_PER_ELEMENT},{name:"aTextureId",size:1,type:E,stride:24,offset:4*Float32Array.BYTES_PER_ELEMENT},{name:"aColor",size:4,type:5121,stride:24,offset:5*Float32Array.BYTES_PER_ELEMENT,normalized:!0}],S=[{name:"aPosition",size:2,type:E,stride:20},{name:"aColor",size:4,type:5121,stride:20,offset:2*Float32Array.BYTES_PER_ELEMENT,normalized:!0},{name:"aRegion",size:2,type:E,stride:20,offset:3*Float32Array.BYTES_PER_ELEMENT}];class A{constructor(t,e,r,s,i=0){this.attributeLoc={},this.uniformLoc={},this.textureUnitNum=0,this.attributes=[];const n=function(t,e){if(t.includes("%TEXTURE_NUM%")&&(t=t.replace("%TEXTURE_NUM%",e.toString())),t.includes("%GET_COLOR%")){let r="";for(let t=0;t<e;t++)r+=0==t?`if(vTextureId == ${t}.0)`:t==e-1?"else":`else if(vTextureId == ${t}.0)`,r+=`{color = texture2D(uTextures[${t}], vRegion);}`;t=t.replace("%GET_COLOR%",r)}return t}(r,t.maxTextureUnits-i);this.program=((t,e,r)=>{var s=t.createProgram(),i=y(t,e,35633),n=y(t,r,35632);if(!s)throw new Error("Unable to create program shader");if(t.attachShader(s,i),t.attachShader(s,n),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS)){const e=t.getProgramInfoLog(s);throw new Error("Unable to link shader program: "+e)}return s})(t.gl,e,n),this.gl=t.gl,this.textureUnitNum=i,this.parseShader(e),this.parseShader(n),s&&this.setAttributes(s)}setUniforms(t,e){const r=this.gl;for(const s of t.getUnifromNames()){const i=this.getUniform(s);t.bind(r,s,i,e)}}getUniform(t){return this.uniformLoc[t]}use(){this.gl.useProgram(this.program)}parseShader(t){const e=this.gl,r=t.match(/attribute\s+\w+\s+(\w+)/g);if(r)for(const t of r){const r=t.split(" ")[2],s=e.getAttribLocation(this.program,r);-1!=s&&(this.attributeLoc[r]=s)}const s=t.match(/uniform\s+\w+\s+(\w+)/g);if(s)for(const t of s){const r=t.split(" ")[2];this.uniformLoc[r]=e.getUniformLocation(this.program,r)}}setAttribute(t){const e=this.attributeLoc[t.name];if(void 0!==e){const r=this.gl;r.vertexAttribPointer(e,t.size,t.type,t.normalized||!1,t.stride,t.offset||0),r.enableVertexAttribArray(e)}}setAttributes(t){this.attributes=t;for(const e of t)this.setAttribute(e)}updateAttributes(){this.setAttributes(this.attributes)}static createCostumShader(t,e,r,s,i=0){let n={[exports.ShaderType.SPRITE]:b,[exports.ShaderType.GRAPHIC]:g}[s],a={[exports.ShaderType.SPRITE]:w,[exports.ShaderType.GRAPHIC]:m}[s];const o={[exports.ShaderType.SPRITE]:R,[exports.ShaderType.GRAPHIC]:S}[s];return n=n.replace("void main(void) {",r+"\nvoid main(void) {"),a=a.replace("void main(void) {",e+"\nvoid main(void) {"),n=n.replace("// fragment","fragment(color);"),a=a.replace(/\/\/ vertex s[\s\S]*?\/\/ vertex e/,"vec2 position = aPosition;\n            vertex(position, vRegion);\n            gl_Position = uProjectionMatrix * vec4(position, 0.0, 1.0);"),new A(t,a,n,o,i)}}class M{constructor(t){this.usedTextures=[],this.shaders=new Map,this.isCostumShader=!1,this.freeTextureUnitNum=0,this.rapid=t,this.gl=t.gl,this.webglArrayBuffer=new h(t.gl,exports.ArrayType.Float32,t.gl.ARRAY_BUFFER,t.gl.STREAM_DRAW),this.maxTextureUnits=t.maxTextureUnits}getTextureUnitList(){return Array.from({length:this.maxTextureUnits},((t,e)=>e))}addVertex(t,e,...r){const[s,i]=this.rapid.matrixStack.apply(t,e);this.webglArrayBuffer.pushFloat32(s),this.webglArrayBuffer.pushFloat32(i)}useTexture(t){const e=this.usedTextures.indexOf(t);return-1==e?(this.usedTextures.push(t),this.freeTextureUnitNum=this.maxTextureUnits-this.usedTextures.length,[this.usedTextures.length-1,!0]):[e,!1]}enterRegion(t){this.currentShader=t??this.getShader("default"),this.currentShader.use(),this.initializeForNextRender(),this.webglArrayBuffer.bindBuffer(),this.currentShader.updateAttributes(),this.updateProjection(),this.isCostumShader=Boolean(t)}updateProjection(){this.gl.uniformMatrix4fv(this.currentShader.uniformLoc.uProjectionMatrix,!1,this.rapid.projection)}isUnifromChanged(t){return!!t&&(this.costumUnifrom!=t||!!t?.isDirty)}setCurrentUniform(t){t.clearDirty(),this.costumUnifrom=t}exitRegion(){}initDefaultShader(t,e,r){this.setShader("default",t,e,r)}setShader(t,e,r,s){this.webglArrayBuffer.bindBuffer(),this.shaders.set(t,new A(this.rapid,e,r,s)),"default"===t&&(this.defaultShader=this.shaders.get(t))}getShader(t){return this.shaders.get(t)}render(){this.executeRender(),this.initializeForNextRender()}executeRender(){const t=this.gl;for(let e=0;e<this.usedTextures.length;e++)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,this.usedTextures[e]);this.webglArrayBuffer.bufferData()}initializeForNextRender(){this.webglArrayBuffer.clear(),this.usedTextures.length=0,this.isCostumShader=!1,this.freeTextureUnitNum=this.maxTextureUnits}hasPendingContent(){return!1}isShaderChanged(t){return(t||this.defaultShader)!=this.currentShader}}class v extends M{constructor(t){super(t),this.vertex=0,this.offset=d.ZERO,this.drawType=t.gl.TRIANGLE_FAN,this.setShader("default",m,g,S)}startRender(t,e,r,s){s&&this.currentShader?.setUniforms(s,this),this.offset=new d(t,e),this.vertex=0,this.webglArrayBuffer.clear(),r&&r.base&&(this.texture=this.useTexture(r.base.texture)[0])}addVertex(t,e,r,s,i){this.webglArrayBuffer.resize(3),super.addVertex(t+this.offset.x,e+this.offset.y),this.webglArrayBuffer.pushUint32(i),this.webglArrayBuffer.pushFloat32(r),this.webglArrayBuffer.pushFloat32(s),this.vertex+=1}executeRender(){super.executeRender();const t=this.gl;t.uniform1i(this.currentShader.uniformLoc.uUseTexture,void 0===this.texture?0:1),this.texture&&t.uniform1i(this.currentShader.uniformLoc.uTexture,this.texture),t.drawArrays(this.drawType,0,this.vertex),this.drawType=this.rapid.gl.TRIANGLE_FAN,this.vertex=0,this.texture=void 0}}const U=Math.floor(16384);class F extends l{constructor(t,e){super(t,6,4,e)}addObject(t){super.addObject(),this.pushUint16(t),this.pushUint16(t+1),this.pushUint16(t+2),this.pushUint16(t),this.pushUint16(t+3),this.pushUint16(t+2)}}class _ extends M{constructor(t){const e=t.gl;super(t),this.batchSprite=0,this.spriteTextureUnits=[],this.spriteTextureUnitIndexOffset=0,this.setShader("default",w,b,R),this.indexBuffer=new F(e,U)}addVertex(t,e,r,s,i,n){super.addVertex(t,e),this.webglArrayBuffer.pushFloat32(r),this.webglArrayBuffer.pushFloat32(s),this.webglArrayBuffer.pushFloat32(i),this.webglArrayBuffer.pushUint32(n)}renderSprite(t,e,r,s,i,n,a,o,h,u,l,c,d,p=0){(1+p>this.freeTextureUnitNum||this.batchSprite>=U||this.isUnifromChanged(l)||this.rapid.projectionDirty)&&(this.render(),l&&this.isUnifromChanged(l)&&(this.currentShader.setUniforms(l,this),this.setCurrentUniform(l)),this.rapid.projectionDirty&&this.updateProjection()),this.batchSprite++,this.webglArrayBuffer.resize(20);const[f,x]=this.useTexture(t);x&&(this.spriteTextureUnits.push(f),this.spriteTextureUnitIndexOffset=this.spriteTextureUnits[0]);const g=f-this.spriteTextureUnitIndexOffset,m=c?n:s,y=c?s:n,T=d?a:i,E=d?i:a,b=o,w=o+e,R=h,S=h+r;this.addVertex(b,R,m,T,g,u),this.addVertex(w,R,y,T,g,u),this.addVertex(w,S,y,E,g,u),this.addVertex(b,S,m,E,g,u)}executeRender(){if(super.executeRender(),this.batchSprite<=0)return;const t=this.gl;this.spriteTextureUnits.length>0&&this.gl.uniform1iv(this.currentShader.uniformLoc.uTextures,this.spriteTextureUnits),t.drawElements(t.TRIANGLES,6*this.batchSprite,t.UNSIGNED_SHORT,0)}enterRegion(t){super.enterRegion(t),this.indexBuffer.bindBuffer()}initializeForNextRender(){super.initializeForNextRender(),this.batchSprite=0,this.spriteTextureUnits.length=0}hasPendingContent(){return this.batchSprite>0}}class C{constructor(t,e){this.cache=new Map,this.render=t,this.antialias=e}async textureFromUrl(t,e=this.antialias,r=exports.TextureWrapMode.CLAMP){let s=this.cache.get(t);if(!s){const i=await this.loadImage(t);s=N.fromImageSource(this.render,i,e,r),this.cache.set(t,s)}return new B(s)}textureFromFrameBufferObject(t){return new B(t)}async textureFromSource(t,e=this.antialias,r=exports.TextureWrapMode.CLAMP){let s=this.cache.get(t);return s||(s=N.fromImageSource(this.render,t,e,r),this.cache.set(t,s)),new B(s)}async loadImage(t){return new Promise((e=>{const r=new Image;r.onload=()=>{e(r)},r.src=t}))}createText(t){return new I(this.render,t)}destroy(t){t instanceof B?(t.base?.destroy(this.render.gl),this.removeCache(t)):(t.destroy(this.render.gl),this.removeCache(t))}createFrameBufferObject(t,e,r=this.antialias){return new P(this.render,t,e,r)}removeCache(t){const e=t instanceof B?t.base?.texture:t.texture;e&&this.cache.forEach(((t,r)=>{t===e&&this.cache.delete(r)}))}}class N{constructor(t,e,r,s=exports.TextureWrapMode.CLAMP){this.texture=t,this.width=e,this.height=r,this.wrapMode=s}static fromImageSource(t,e,r=!1,s=exports.TextureWrapMode.CLAMP){return new N(T(t.gl,e,r,!1,!1,s),e.width,e.height)}destroy(t){t.deleteTexture(this.texture)}}class B{constructor(t){this.scale=1,this.setBaseTextur(t)}setBaseTextur(t){t&&(this.base=t,this.setClipRegion(0,0,t.width,t.height))}setClipRegion(t,e,r,s){if(this.base)return this.clipX=t/this.base.width,this.clipY=e/this.base.height,this.clipW=this.clipX+r/this.base.width,this.clipH=this.clipY+s/this.base.height,this.width=r*this.scale,this.height=s*this.scale,this}static fromImageSource(t,e,r=!1){return new B(N.fromImageSource(t,e,r))}static fromUrl(t,e){return t.textures.textureFromUrl(e)}createSpritesHeet(t,e){if(!this.base)return[];const r=[],s=Math.floor(this.base.width/t),i=Math.floor(this.base.height/e);for(let n=0;n<i;n++)for(let i=0;i<s;i++){const s=this.clone();s.setClipRegion(i*t,n*e,t,e),r.push(s)}return r}clone(){return new B(this.base)}}class I extends B{constructor(t,e){super(),this.scale=.5,this.rapid=t,this.options=e,this.text=e.text||" ",this.updateTextImage()}updateTextImage(){const t=this.createTextCanvas();this.setBaseTextur(N.fromImageSource(this.rapid,t,!0))}createTextCanvas(){const t=document.createElement("canvas"),e=t.getContext("2d");if(!e)throw new Error("Failed to get canvas context");e.font=`${this.options.fontSize||16}px ${this.options.fontFamily||"Arial"}`,e.fillStyle=this.options.color||"#000",e.textAlign=this.options.textAlign||"left",e.textBaseline=this.options.textBaseline||"top";const r=this.text.split("\n");let s=0,i=0;for(const t of r){const r=e.measureText(t);s=Math.max(s,r.width),i+=this.options.fontSize||16}t.width=2*s,t.height=2*i,e.scale(2,2),e.font=`${this.options.fontSize||16}px ${this.options.fontFamily||"Arial"}`,e.fillStyle=this.options.color||"#000",e.textAlign=this.options.textAlign||"left",e.textBaseline=this.options.textBaseline||"top";let n=0;for(const t of r)e.fillText(t,0,n),n+=this.options.fontSize||16;return t}setText(t){this.text!=t&&(this.text=t,this.updateTextImage())}}class P extends N{constructor(t,e,r,s=!1){const i=t.gl,n=T(i,{width:e,height:r},s,!0,!1),a=i.createFramebuffer();if(!a)throw i.deleteTexture(n),new Error("Failed to create WebGL framebuffer");i.bindFramebuffer(i.FRAMEBUFFER,a),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,n,0);const o=i.createRenderbuffer();if(!o)throw i.deleteFramebuffer(a),i.deleteTexture(n),new Error("Failed to create depth-stencil renderbuffer");i.bindRenderbuffer(i.RENDERBUFFER,o),i.renderbufferStorage(i.RENDERBUFFER,i.STENCIL_INDEX8,e,r),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.STENCIL_ATTACHMENT,i.RENDERBUFFER,o),super(n,e,r),this.gl=i,this.framebuffer=a,i.bindTexture(i.TEXTURE_2D,null),i.bindFramebuffer(i.FRAMEBUFFER,null)}bind(){const t=this.gl;t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.clearColor(.5,.2,.5,.5),t.clear(t.COLOR_BUFFER_BIT)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}resize(t,e){this.width=t,this.height=e,this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,t,e,0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}destroy(t){t.deleteFramebuffer(this.framebuffer),super.destroy(t)}}const L=new Set;class D{constructor(t,e){this.textures=new Map,this.width=t,this.height=e}setTile(t,e){e instanceof B&&(e={texture:e}),this.textures.set(t,e)}getTile(t){return this.textures.get(t)}}class k{constructor(t){this.rapid=t}getYSortRow(t,e,r){if(!t)return[];const s=[];for(const r of t){const t=Math.floor(r.ySort/e);s[t]||(s[t]=[]),s[t].push(r)}return s}getOffset(t){let e=(t.errorX??2)+1,r=(t.errorY??2)+1;if("number"==typeof t.error){const s=(t.error??2)+1;e=s,r=s}else t.error&&(e=t.error.x+1,r=t.error.y+1);return{errorX:e,errorY:r}}getTileData(t,e){const r=e.shape??exports.TilemapShape.SQUARE,s=t.width,i=r===exports.TilemapShape.ISOMETRIC?t.height/2:t.height,n=this.rapid.matrixStack,a=n.globalToLocal(d.ZERO),o=n.getGlobalScale(),{errorX:h,errorY:u}=this.getOffset(e),l=Math.ceil(this.rapid.width/s/o.x)+2*h,c=Math.ceil(this.rapid.height/i/o.y)+2*u,p=new d(a.x<0?Math.ceil(a.x/s):Math.floor(a.x/s),a.y<0?Math.ceil(a.y/i):Math.floor(a.y/i));p.x-=h,p.y-=u;let f=new d(0-a.x%s-h*s,0-a.y%i-u*i);return f=f.add(a),{startTile:p,offset:f,viewportWidth:l,viewportHeight:c,height:i,width:s,shape:r}}renderYSortRow(t,e){for(const r of e)r.render?r.render():r.renderSprite&&t.renderSprite(r.renderSprite)}renderLayer(t,e){this.rapid.matrixStack.applyTransform(e);const r=e.tileSet,{startTile:s,offset:i,viewportWidth:n,viewportHeight:a,shape:o,width:h,height:u}=this.getTileData(r,e),l=this.getYSortRow(e.ySortCallback,u,a),c=e.ySortCallback&&e.ySortCallback.length>0;var d;0!==this.rapid.matrixStack.getGlobalRotation()&&(d="TileMapRender: tilemap is not supported rotation",L.has(d)||(L.add(d),console.warn(d)),this.rapid.matrixStack.setGlobalRotation(0));for(let d=0;d<a;d++){const a=d+s.y,p=l[a]??[];if(a<0||a>=t.length)this.renderYSortRow(this.rapid,p);else{for(let l=0;l<n;l++){const n=l+s.x;if(n<0||n>=t[a].length)continue;const c=t[a][n],f=r.getTile(c);if(!f)continue;let x=l*h+i.x,g=d*u+i.y,m=d*u+i.y+(f.ySortOffset??0);a%2!=0&&o===exports.TilemapShape.ISOMETRIC&&(x+=h/2);const y=e.eachTile&&e.eachTile(c,n,a)||{};p.push({ySort:m,renderSprite:{...f,x:x+(f.x||0),y:g+(f.y||0),...y}})}c&&p.sort(((t,e)=>t.ySort-e.ySort)),this.renderYSortRow(this.rapid,p)}}this.rapid.matrixStack.applyTransform(e)}localToMap(t,e){const r=e.tileSet;if(e.shape===exports.TilemapShape.ISOMETRIC){let e=0,s=0;const i=r.height/2,n=r.width/2;let a=Math.floor(t.y/i);const o=a%2==0;let h=Math.floor(t.x/n);const u=h%2==0,l=t.x%n/n,c=t.y%i/i,p=c<l,f=c<1-l;return o||(a-=1),p&&!u&&o?a-=1:p||!u||o?f&&u&&o?(h-=2,a-=1):f||u||o||(a+=1):(a+=1,h-=2),e=h,s=a,e=Math.floor(h/2),new d(e,s)}return new d(Math.floor(t.x/r.width),Math.floor(t.y/r.height))}mapToLocal(t,e){const r=e.tileSet;if(e.shape===exports.TilemapShape.ISOMETRIC){let e=new d(t.x*r.width,t.y*r.height/2);return t.y%2!=0&&(e.x+=r.width/2),e}return new d(t.x*r.width,t.y*r.height)}}exports.BaseTexture=N,exports.Color=c,exports.DynamicArrayBuffer=o,exports.FrameBufferObject=P,exports.GLShader=A,exports.MathUtils=class{static deg2rad(t){return t*(Math.PI/180)}static rad2deg(t){return t/(Math.PI/180)}static normalizeDegrees(t){return(t%360+360)%360}},exports.MatrixStack=u,exports.Rapid=class{constructor(t){this.projectionDirty=!0,this.matrixStack=new u,this.tileMap=new k(this),this.light=new p(this),this.devicePixelRatio=window.devicePixelRatio||1,this.defaultColor=new c(255,255,255,255),this.regions=new Map,this.currentMaskType=[],this.currentTransform=[],this.currentFBO=[];const e=(t=>{const e={stencil:!0},r=t.getContext("webgl2",e)||t.getContext("webgl",e);if(!r)throw new Error("Unable to initialize WebGL. Your browser may not support it.");return r})(t.canvas);this.gl=e,this.canvas=t.canvas,this.textures=new C(this,t.antialias??!1),this.maxTextureUnits=e.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.width=t.width||this.canvas.width,this.height=t.width||this.canvas.height,this.backgroundColor=t.backgroundColor||new c(255,255,255,255),this.registerBuildInRegion(),this.initWebgl(e),this.projectionDirty=!1}renderTileMapLayer(t,e){this.tileMap.renderLayer(t,e instanceof D?{tileSet:e}:e)}initWebgl(t){this.resize(this.width,this.height),t.enable(t.BLEND),t.disable(t.DEPTH_TEST),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.enable(t.STENCIL_TEST),t.enable(t.SCISSOR_TEST)}clearTextureUnit(){for(let t=0;t<this.maxTextureUnits;t++)this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}registerBuildInRegion(){this.registerRegion("sprite",_),this.registerRegion("graphic",v)}registerRegion(t,e){this.regions.set(t,new e(this))}quitCurrentRegion(){this.currentRegion&&this.currentRegion.hasPendingContent()&&(this.currentRegion.render(),this.currentRegion.exitRegion())}setRegion(t,e){if(t!=this.currentRegionName||this.currentRegion&&this.currentRegion.isShaderChanged(e)){const r=this.regions.get(t);this.quitCurrentRegion(),this.currentRegion=r,this.currentRegionName=t,r.enterRegion(e)}}save(){this.matrixStack.pushMat()}restore(){this.matrixStack.popMat()}withTransform(t){this.save(),t(),this.restore()}startRender(t=!0){this.clear(),t&&this.matrixStack.clear(),this.matrixStack.pushIdentity(),this.currentRegion=void 0,this.currentRegionName=void 0}endRender(){this.currentRegion?.render(),this.projectionDirty=!1}render(t){this.startRender(),t(),this.endRender()}renderSprite(t){const e=t.texture;if(!e||!e.base)return;const{offsetX:r,offsetY:s}=this.startDraw(t,e.width,e.height);this.setRegion("sprite",t.shader),this.currentRegion.renderSprite(e.base.texture,e.width,e.height,e.clipX,e.clipY,e.clipW,e.clipH,r,s,(t.color||this.defaultColor).uint32,t.uniforms,t.flipX,t.flipY),this.afterDraw()}renderTexture(t){t.base&&this.renderSprite({texture:t})}renderLine(t){const e=t.closed?[...t.points,t.points[0]]:t.points,{vertices:r,uv:s}=x({...t,points:e});this.renderGraphic({...t,drawType:this.gl.TRIANGLES,points:r,uv:s})}renderGraphic(t){this.startGraphicDraw(t),t.points.forEach(((e,r)=>{const s=Array.isArray(t.color)?t.color[r]:t.color,i=t.uv?.[r];this.addGraphicVertex(e.x,e.y,i,s)})),this.endGraphicDraw()}startGraphicDraw(t){const{offsetX:e,offsetY:r}=this.startDraw(t);this.setRegion("graphic",t.shader);const s=this.currentRegion;s.startRender(e,r,t.texture,t.uniforms),t.drawType&&(s.drawType=t.drawType)}addGraphicVertex(t,e,r,s){this.currentRegion.addVertex(t,e,r?.x,r?.y,(s||this.defaultColor).uint32)}endGraphicDraw(){this.currentRegion.render(),this.afterDraw()}startDraw(t,e=0,r=0){return this.currentTransform.push(t),this.matrixStack.applyTransform(t,e,r)}afterDraw(){this.currentTransform.length>0&&this.matrixStack.applyTransformAfter(this.currentTransform.pop())}renderRect(t){const{width:e,height:r}=t,s=[new d(0,0),new d(e,0),new d(e,r),new d(0,r)];this.renderGraphic({...t,points:s,drawType:this.gl.TRIANGLE_FAN})}renderCircle(t){const e=t.segments||32,r=t.radius,s=t.color||this.defaultColor,i=[];for(let t=0;t<=e;t++){const s=t/e*Math.PI*2,n=Math.cos(s)*r,a=Math.sin(s)*r;i.push(new d(n,a))}this.renderGraphic({...t,points:i,color:s,drawType:this.gl.TRIANGLE_FAN})}resize(t,e){const r=t*this.devicePixelRatio,s=e*this.devicePixelRatio;this.canvas.width=r,this.canvas.height=s,this.resizeWebglSize(t,e),this.canvas.style.width=t+"px",this.canvas.style.height=e+"px",this.width=t,this.height=e}resizeWebglSize(t,e,r){const s=t*(r||this.devicePixelRatio),i=e*(r||this.devicePixelRatio);this.gl.viewport(0,0,s,i),this.updateProjection(0,t,e,0),this.gl.scissor(0,0,s,i)}updateProjection(t,e,r,s){this.projection=this.createOrthMatrix(t,e,r,s),this.projectionDirty=!0}clear(t){const e=this.gl,r=t||this.backgroundColor;e.clearColor(r.r/255,r.g/255,r.b/255,r.a/255),e.clear(e.COLOR_BUFFER_BIT),this.clearMask()}createOrthMatrix(t,e,r,s){return new Float32Array([2/(e-t),0,0,0,0,2/(s-r),0,0,0,0,-1,0,-(e+t)/(e-t),-(s+r)/(s-r),0,1])}drawMask(t=exports.MaskType.Include,e){this.startDrawMask(t),e(),this.endDrawMask()}startDrawMask(t=exports.MaskType.Include){const e=this.gl;this.currentMaskType.push(t),this.setMaskType(t,!0),e.stencilOp(e.KEEP,e.KEEP,e.REPLACE),e.colorMask(!1,!1,!1,!1)}endDrawMask(){const t=this.gl;this.quitCurrentRegion(),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.colorMask(!0,!0,!0,!0),this.setMaskType(this.currentMaskType.pop()??exports.MaskType.Include,!1)}setMaskType(t,e=!1){const r=this.gl;if(this.quitCurrentRegion(),e)this.clearMask(),r.stencilFunc(r.ALWAYS,1,255);else switch(t){case exports.MaskType.Include:r.stencilFunc(r.EQUAL,1,255);break;case exports.MaskType.Exclude:r.stencilFunc(r.NOTEQUAL,1,255)}}clearMask(){const t=this.gl;this.quitCurrentRegion(),t.clearStencil(0),t.clear(t.STENCIL_BUFFER_BIT),t.stencilFunc(t.ALWAYS,1,255)}createCostumShader(t,e,r,s=0){return A.createCostumShader(this,t,e,r,s)}startFBO(t){this.quitCurrentRegion(),t.bind(),this.clearTextureUnit(),this.resizeWebglSize(t.width,t.height,1),this.updateProjection(0,t.width,0,t.height),this.save(),this.matrixStack.identity(),this.currentFBO.push(t)}endFBO(){if(this.currentFBO.length>0){const t=this.currentFBO.pop();this.quitCurrentRegion(),t.unbind(),this.clearTextureUnit(),this.resizeWebglSize(this.width,this.height),this.updateProjection(0,this.width,this.height,0),this.restore()}}drawToFBO(t,e){this.startFBO(t),e(),this.endFBO()}setBlendMode(t){switch(t){case exports.BlendMode.Additive:this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);break;case exports.BlendMode.Subtractive:this.gl.blendFunc(this.gl.ZERO,this.gl.ONE_MINUS_SRC_COLOR);break;case exports.BlendMode.Mix:this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA)}}drawLightShadowMask(t){this.startDrawMask(t.type||exports.MaskType.Exclude);this.light.createLightShadowMaskPolygon(t.occlusion,t.lightSource,t.baseProjectionLength).forEach((t=>{this.renderGraphic({points:t,color:c.Black})})),this.endDrawMask()}},exports.SCALEFACTOR=2,exports.Text=I,exports.Texture=B,exports.TextureCache=C,exports.TileMapRender=k,exports.TileSet=D,exports.Uniform=class{constructor(t){this.isDirty=!1,this.data=t}setUniform(t,e){this.data[t]!=e&&(this.isDirty=!0),this.data[t]=e}clearDirty(){this.isDirty=!1}getUnifromNames(){return Object.keys(this.data)}bind(t,e,r,s){if(!r)return;const i=this.data[e];if("number"==typeof i)t.uniform1f(r,i);else if(Array.isArray(i))switch(i.length){case 1:Number.isInteger(i[0])?t.uniform1i(r,i[0]):t.uniform1f(r,i[0]);break;case 2:Number.isInteger(i[0])?t.uniform2iv(r,i):t.uniform2fv(r,i);break;case 3:Number.isInteger(i[0])?t.uniform3iv(r,i):t.uniform3fv(r,i);break;case 4:Number.isInteger(i[0])?t.uniform4iv(r,i):t.uniform4fv(r,i);break;case 9:t.uniformMatrix3fv(r,!1,i);break;case 16:t.uniformMatrix4fv(r,!1,i);break;default:console.error(`Unsupported uniform array length for ${e}:`,i.length)}else if("boolean"==typeof i)t.uniform1i(r,i?1:0);else if(i.base?.texture){const e=s.useTexture(i.base.texture)[0];t.uniform1i(r,e)}else console.error(`Unsupported uniform type for ${e}:`,typeof i)}},exports.Vec2=d,exports.WebglBufferArray=h,exports.WebglElementBufferArray=l,exports.graphicAttributes=S,exports.spriteAttributes=R;
