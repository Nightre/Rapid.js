var t,e,i,r,s,a,n,h;!function(t){t.KEEP="keep",t.KEEP_H="keep_h",t.KEEP_W="keep_w",t.IGNORE="ignore",t.EXPAND="expand"}(t||(t={})),function(t){t.STRETCH="stretch",t.REPEAT="repeat"}(e||(e={})),function(t){t.REPEAT="repeat",t.CLAMP="clamp",t.MIRROR="mirror"}(i||(i={})),function(t){t.Include="normal",t.Exclude="inverse"}(r||(r={})),function(t){t.SQUARE="square",t.ISOMETRIC="isometric"}(s||(s={})),function(t){t.SPRITE="sprite",t.GRAPHIC="graphic"}(a||(a={})),function(t){t.Additive="additive",t.Subtractive="subtractive",t.Mix="mix"}(n||(n={})),function(t){t.POINT="point",t.CIRCLE="circle",t.RECT="rect"}(h||(h={}));var o;!function(t){t[t.Float32=0]="Float32",t[t.Uint32=1]="Uint32",t[t.Uint16=2]="Uint16"}(o||(o={}));class l{constructor(t){this.usedElemNum=0,this.maxElemNum=512,this.bytePerElem=this.getArrayType(t).BYTES_PER_ELEMENT,this.arrayType=t,this.arraybuffer=new ArrayBuffer(this.maxElemNum*this.bytePerElem),this.updateTypedArray()}getArrayType(t){switch(t){case o.Float32:return Float32Array;case o.Uint32:return Uint32Array;case o.Uint16:return Uint16Array}}updateTypedArray(){switch(this.uint32=new Uint32Array(this.arraybuffer),this.float32=new Float32Array(this.arraybuffer),this.uint16=new Uint16Array(this.arraybuffer),this.arrayType){case o.Float32:this.typedArray=this.float32;break;case o.Uint32:this.typedArray=this.uint32;break;case o.Uint16:this.typedArray=this.uint16}}clear(){this.usedElemNum=0}resize(t=0){if((t+=this.usedElemNum)>this.maxElemNum){for(;t>this.maxElemNum;)this.maxElemNum<<=1;this.setMaxSize(this.maxElemNum)}}setMaxSize(t=this.maxElemNum){const e=this.typedArray;this.maxElemNum=t,this.arraybuffer=new ArrayBuffer(t*this.bytePerElem),this.updateTypedArray(),this.typedArray.set(e)}pushUint32(t){this.uint32[this.usedElemNum++]=t}pushFloat32(t){this.float32[this.usedElemNum++]=t}pushUint16(t){this.uint16[this.usedElemNum++]=t}pop(t){this.usedElemNum-=t}getArray(t=0,e){return null==e?this.typedArray:this.typedArray.subarray(t,e)}get length(){return this.typedArray.length}}class u extends l{constructor(t,e,i=t.ARRAY_BUFFER,r=t.STATIC_DRAW){super(e),this.dirty=!0,this.webglBufferSize=0,this.gl=t,this.buffer=t.createBuffer(),this.type=i,this.usage=r}pushFloat32(t){super.pushFloat32(t),this.dirty=!0}pushUint32(t){super.pushUint32(t),this.dirty=!0}pushUint16(t){super.pushUint16(t),this.dirty=!0}bindBuffer(){this.gl.bindBuffer(this.type,this.buffer)}bufferData(){if(this.dirty){const t=this.gl;this.maxElemNum>this.webglBufferSize?(t.bufferData(this.type,this.getArray(),this.usage),this.webglBufferSize=this.maxElemNum):t.bufferSubData(this.type,0,this.getArray(0,this.usedElemNum)),this.dirty=!1}}}class c extends l{constructor(){super(o.Float32)}pushMat(){const t=this.usedElemNum-6,e=this.typedArray;this.resize(6),this.pushFloat32(e[t+0]),this.pushFloat32(e[t+1]),this.pushFloat32(e[t+2]),this.pushFloat32(e[t+3]),this.pushFloat32(e[t+4]),this.pushFloat32(e[t+5])}popMat(){this.pop(6)}pushIdentity(){this.resize(6),this.pushFloat32(1),this.pushFloat32(0),this.pushFloat32(0),this.pushFloat32(1),this.pushFloat32(0),this.pushFloat32(0)}translate(t,e){if("number"!=typeof t)return this.translate(t.x,t.y);const i=this.usedElemNum-6,r=this.typedArray;r[i+4]=r[i+0]*t+r[i+2]*e+r[i+4],r[i+5]=r[i+1]*t+r[i+3]*e+r[i+5]}rotate(t){const e=this.usedElemNum-6,i=this.typedArray,r=Math.cos(t),s=Math.sin(t),a=i[e+0],n=i[e+1],h=i[e+2],o=i[e+3];i[e+0]=a*r-n*s,i[e+1]=a*s+n*r,i[e+2]=h*r-o*s,i[e+3]=h*s+o*r}scale(t,e){if("number"!=typeof t)return this.scale(t.x,t.y);e||(e=t);const i=this.usedElemNum-6,r=this.typedArray;r[i+0]=r[i+0]*t,r[i+1]=r[i+1]*t,r[i+2]=r[i+2]*e,r[i+3]=r[i+3]*e}apply(t,e){if("number"!=typeof t)return new f(...this.apply(t.x,t.y));const i=this.usedElemNum-6,r=this.typedArray;return[r[i+0]*t+r[i+2]*e+r[i+4],r[i+1]*t+r[i+3]*e+r[i+5]]}getInverse(){const t=this.usedElemNum-6,e=this.typedArray,i=e[t+0],r=e[t+1],s=e[t+2],a=e[t+3],n=e[t+4],h=e[t+5],o=i*a-r*s;return new Float32Array([a/o,-r/o,-s/o,i/o,(s*h-a*n)/o,(r*n-i*h)/o])}getTransform(){const t=this.usedElemNum-6,e=this.typedArray;return new Float32Array([e[t+0],e[t+1],e[t+2],e[t+3],e[t+4],e[t+5]])}setTransform(t){const e=this.usedElemNum-6,i=this.typedArray;i[e+0]=t[0],i[e+1]=t[1],i[e+2]=t[2],i[e+3]=t[3],i[e+4]=t[4],i[e+5]=t[5]}getGlobalPosition(){const t=this.usedElemNum-6,e=this.typedArray;return new f(e[t+4],e[t+5])}setGlobalPosition(t,e){if("number"!=typeof t)return void this.setGlobalPosition(t.x,t.y);const i=this.usedElemNum-6,r=this.typedArray;r[i+4]=t,r[i+5]=e}getGlobalRotation(){const t=this.usedElemNum-6,e=this.typedArray;return Math.atan2(e[t+1],e[t+0])}setGlobalRotation(t){const e=this.usedElemNum-6,i=this.typedArray,r=this.getGlobalScale(),s=Math.cos(t),a=Math.sin(t);i[e+0]=s*r.x,i[e+1]=a*r.x,i[e+2]=-a*r.y,i[e+3]=s*r.y}getGlobalScale(){const t=this.usedElemNum-6,e=this.typedArray,i=Math.sqrt(e[t+0]*e[t+0]+e[t+1]*e[t+1]),r=Math.sqrt(e[t+2]*e[t+2]+e[t+3]*e[t+3]);return new f(i,r)}setGlobalScale(t,e){if("number"!=typeof t)return void this.setGlobalScale(t.x,t.y);const i=this.getGlobalRotation(),r=Math.cos(i),s=Math.sin(i),a=this.usedElemNum-6,n=this.typedArray;n[a+0]=r*t,n[a+1]=s*t,n[a+2]=-s*e,n[a+3]=r*e}globalToLocal(t){const e=this.getInverse();return new f(e[0]*t.x+e[2]*t.y+e[4],e[1]*t.x+e[3]*t.y+e[5])}localToGlobal(t){return this.apply(t)}toCSSTransform(){const t=this.usedElemNum-6,e=this.typedArray;return`matrix(${e[t+0]}, ${e[t+1]}, ${e[t+2]}, ${e[t+3]}, ${e[t+4]}, ${e[t+5]})`}identity(){const t=this.usedElemNum-6,e=this.typedArray;e[t+0]=1,e[t+1]=0,e[t+2]=0,e[t+3]=1,e[t+4]=0,e[t+5]=0}applyTransform(t,e=0,i=0){(t.saveTransform??1)&&this.pushMat(),t.afterSave&&t.afterSave();const r=t.x||0,s=t.y||0;(r||s)&&this.translate(r,s),t.position&&this.translate(t.position),t.rotation&&this.rotate(t.rotation),t.scale&&this.scale(t.scale);let a=t.offsetX||0,n=t.offsetY||0;t.offset&&(a+=t.offset.x,n+=t.offset.y);const h=t.origin;return h&&("number"==typeof h?(a-=h*e,n-=h*i):(a-=h.x*e,n-=h.y*i)),{offsetX:a,offsetY:n}}applyTransformAfter(t){t.beforRestore&&t.beforRestore(),(t.restoreTransform??1)&&this.popMat()}}class d extends u{constructor(t,e,i,r){super(t,o.Uint16,t.ELEMENT_ARRAY_BUFFER,t.STATIC_DRAW),this.setMaxSize(e*r);for(let t=0;t<r;t++)this.addObject(t*i);this.bindBuffer(),this.bufferData()}addObject(t){}}class p{constructor(t,e,i,r=255){this._r=t,this._g=e,this._b=i,this._a=r,this.updateUint()}get r(){return this._r}set r(t){this._r=t,this.updateUint()}get g(){return this._g}set g(t){this._g=t,this.updateUint()}get b(){return this._b}set b(t){this._b=t,this.updateUint()}get a(){return this._a}set a(t){this._a=t,this.updateUint()}updateUint(){this.uint32=(this._a<<24|this._b<<16|this._g<<8|this._r)>>>0}setRGBA(t,e,i,r){this.r=t,this.g=e,this.b=i,this.a=r,this.updateUint()}copy(t){this.setRGBA(t.r,t.g,t.b,t.a)}clone(){return new p(this._r,this._g,this._b,this._a)}equal(t){return t.r===this.r&&t.g===this.g&&t.b===this.b&&t.a===this.a}static fromHex(t){t.startsWith("#")&&(t=t.slice(1));const e=parseInt(t.slice(0,2),16),i=parseInt(t.slice(2,4),16),r=parseInt(t.slice(4,6),16);let s=255;return t.length>=8&&(s=parseInt(t.slice(6,8),16)),new p(e,i,r,s)}add(t){return new p(Math.min(this.r+t.r,255),Math.min(this.g+t.g,255),Math.min(this.b+t.b,255),Math.min(this.a+t.a,255))}subtract(t){return new p(this.r-t.r,this.g-t.g,this.b-t.b,this.a-t.a)}divide(t){return t instanceof p?new p(this.r/t.r,this.g/t.g,this.b/t.b,this.a/t.a):new p(this.r/t,this.g/t,this.b/t,this.a/t)}multiply(t){return t instanceof p?new p(this.r*t.r,this.g*t.g,this.b*t.b,this.a*t.a):new p(this.r*t,this.g*t,this.b*t,this.a*t)}clamp(){this.r=Math.max(0,Math.min(255,this.r)),this.g=Math.max(0,Math.min(255,this.g)),this.b=Math.max(0,Math.min(255,this.b)),this.a=Math.max(0,Math.min(255,this.a))}}p.Red=new p(255,0,0,255),p.Green=new p(0,255,0,255),p.Blue=new p(0,0,255,255),p.Yellow=new p(255,255,0,255),p.Purple=new p(128,0,128,255),p.Orange=new p(255,165,0,255),p.Pink=new p(255,192,203,255),p.Gray=new p(128,128,128,255),p.Brown=new p(139,69,19,255),p.Cyan=new p(0,255,255,255),p.Magenta=new p(255,0,255,255),p.Lime=new p(192,255,0,255),p.White=new p(255,255,255,255),p.Black=new p(0,0,0,255),p.TRANSPARENT=new p(0,0,0,0);class f{constructor(t,e){this.x=void 0!==t?t:0,this.y=void 0!==e?e:0}add(t){return new f(this.x+t.x,this.y+t.y)}subtract(t){return new f(this.x-t.x,this.y-t.y)}multiply(t){return t instanceof f?new f(this.x*t.x,this.y*t.y):new f(this.x*t,this.y*t)}divide(t){return t instanceof f?new f(this.x/t.x,this.y/t.y):new f(this.x/t,this.y/t)}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}distanceTo(t){const e=this.x-t.x,i=this.y-t.y;return Math.sqrt(e*e+i*i)}clone(){return new f(this.x,this.y)}copy(t){this.x=t.x,this.y=t.y}equal(t){return t.x==this.x&&t.y==this.y}perpendicular(){const t=this.x;return this.x=-this.y,this.y=t,this}invert(){return this.x=-this.x,this.y=-this.y,this}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return this.x=this.x/t||0,this.y=this.y/t||0,this}angle(){return Math.atan2(this.y,this.x)}middle(t){return new f((this.x+t.x)/2,(this.y+t.y)/2)}abs(){return new f(Math.abs(this.x),Math.abs(this.y))}floor(){return new f(Math.floor(this.x),Math.floor(this.y))}ceil(){return new f(Math.ceil(this.x),Math.ceil(this.y))}snap(t){return new f(Math.round(this.x/t)*t,Math.round(this.y/t)*t)}stringify(){return`Vec2(${this.x}, ${this.y})`}static FromArray(t){return t.map((t=>new f(t[0],t[1])))}static fromAngle(t){return new f(Math.cos(t),Math.sin(t))}angleBetween(t){const e=this.dot(t),i=this.length()*t.length(),r=Math.max(-1,Math.min(1,e/i));return Math.acos(r)}}f.ZERO=new f(0,0),f.ONE=new f(1,1),f.UP=new f(0,1),f.DOWN=new f(0,-1),f.LEFT=new f(-1,0),f.RIGHT=new f(1,0);class m{static deg2rad(t){return t*(Math.PI/180)}static rad2deg(t){return t/(Math.PI/180)}static normalizeDegrees(t){return(t%360+360)%360}}class g{static float(t,e){return Math.random()*(e-t)+t}static int(t,e){return Math.floor(Math.random()*(e-t+1))+t}static angle(){return Math.random()*Math.PI*2}static vector(t,e,i,r){return new f(g.float(t,e),g.float(i,r))}static direction(t){const e=g.angle();return new f(Math.cos(e)*t,Math.sin(e)*t)}static randomColor(t,e){return new p(g.float(t.r,e.r),g.float(t.g,e.g),g.float(t.b,e.b),g.float(t.a,e.a))}static pick(t){return t[g.int(0,t.length-1)]}static pickWeight(t){if(!t||0===t.length)return null;let e=0;for(const i of t)e+=i[1];const i=Math.random()*e;let r=0;for(const e of t)if(r+=e[1],i<=r)return e[0];return t[t.length-1][0]}static scalarOrRange(t,e){if(void 0===t)return e;if(Array.isArray(t)){if("number"==typeof t[0])return g.float(t[0],t[1]);if(t[0]instanceof f)return g.vector(t[0].x,t[1].x,t[0].y,t[1].y);if(t[0]instanceof p)return g.randomColor(t[0],t[1])}return"number"==typeof t?t:t.clone()}}class x{constructor(t){this.render=t}createLightShadowMaskPolygon(t,e,i){const r=[];t.forEach((t=>{for(let e=0;e<t.length;e++){const i=t[e],s=t[(e+1)%t.length];r.push([i,s])}})),i=i||Math.sqrt(Math.pow(this.render.width,2)+Math.pow(this.render.height,2));const s=[];return r.forEach((([t,r])=>{const a=new f(t.x-e.x,t.y-e.y),n=new f(r.x-e.x,r.y-e.y),h=r.subtract(t).perpendicular(),o=Math.abs(h.dot(a))/(h.length()*a.length())+.01,l=Math.abs(h.dot(n))/(h.length()*n.length())+.01,u=i/o,c=i/l,d=new f(a.x,a.y).normalize(),p=new f(n.x,n.y).normalize(),m=new f(t.x+d.x*u,t.y+d.y*u),g=new f(r.x+p.x*c,r.y+p.y*c);s.push([t,r,g,m])})),s}}const y=(t,e,i,r)=>{const s=[],a=r?Math.atan2(e.y,e.x):Math.atan2(-e.y,-e.x),n=Math.PI;for(let e=0;e<10;e++){const r=a+e/10*n,h=a+(e+1)/10*n,o=Math.cos(r)*i,l=Math.sin(r)*i,u=Math.cos(h)*i,c=Math.sin(h)*i;s.push(t),s.push(t.add(new f(o,l))),s.push(t.add(new f(u,c)))}return s},T=t=>{const i=t.points;if(i.length<2)return{vertices:[],uv:[]};const{normals:r,length:s}=((t,e=!1)=>{const i=[];if(t.length<2||e&&t.length<3)return{normals:i,length:0};const r=t.length;let s=0;if(e)for(let e=0;e<r;e++){const i=t[e],a=t[(e+1)%r];s+=i.distanceTo(a)}else for(let e=0;e<r-1;e++)s+=t[e].distanceTo(t[e+1]);const a=(t,e,i)=>{const r=e.subtract(t).normalize(),s=e.subtract(i).normalize(),a=s.dot(r);if(a<-.999)return{normal:r.perpendicular(),miters:1};{let t=s.add(r).normalize();r.cross(s)<0&&(t=t.multiply(-1));let e=1/Math.sqrt((1-a)/2);return{normal:t,miters:Math.min(e,4)}}};if(e){for(let e=0;e<r-1;e++){const s=0===e?t[r-2]:t[e-1],n=t[e],h=t[e+1];i.push(a(s,n,h))}i.push(i[0])}else for(let e=0;e<r;e++)if(0===e){const e=t[1].subtract(t[0]).normalize();i.push({normal:e.perpendicular(),miters:1})}else if(e===r-1){const r=t[e].subtract(t[e-1]).normalize();i.push({normal:r.perpendicular(),miters:1})}else i.push(a(t[e-1],t[e],t[e+1]));return{normals:i,length:s}})(i,t.closed),a=(t.width||1)/2,n=[],h=[],o=t.roundCap||!1,l=t.textureMode||e.STRETCH;let u=0;const c=t.texture?.width||1;for(let t=0;t<i.length-1;t++){const o=i[t],d=r[t].normal,p=r[t].miters,m=o.add(d.multiply(p*a)),g=o.subtract(d.multiply(p*a)),x=i[t+1],y=r[t+1].normal,T=r[t+1].miters,E=x.add(y.multiply(T*a)),R=x.subtract(y.multiply(T*a)),b=o.distanceTo(x);let w=0,v=0;l===e.STRETCH?(w=u/s,v=(u+b)/s):(w=u/c,v=w+b/c);const S=new f(w,0),A=new f(w,1),M=new f(v,0),U=new f(v,1);n.push(m),h.push(S),n.push(g),h.push(A),n.push(E),h.push(M),n.push(E),h.push(M),n.push(R),h.push(U),n.push(g),h.push(A),u+=b}if(o&&!t.closed){const t=i[0],e=r[0].normal,s=y(t,e,a,!0);n.push(...s);const h=i[i.length-1],o=r[i.length-1].normal,l=y(h,o,a,!1);n.push(...l)}return{vertices:n,uv:h}};var E="precision mediump float;\r\nvarying vec2 vRegion;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uTexture;\r\nuniform int uUseTexture;\r\n\r\nvoid main(void) {\r\n    vec4 color;\r\n    if(uUseTexture > 0){\r\n        color = texture2D(uTexture, vRegion) * vColor;\r\n    }else{\r\n        color = vColor;\r\n    }\r\n    // fragment\r\n    gl_FragColor = color;\r\n}\r\n",R="precision mediump float;\r\n\r\nattribute vec2 aPosition;\r\nattribute vec4 aColor;\r\nattribute vec2 aRegion;\r\n\r\nvarying vec4 vColor;\r\nuniform mat4 uProjectionMatrix;\r\nuniform vec4 uColor;\r\nvarying vec2 vRegion;\r\n\r\nvoid main(void) {\r\n    // vertex s\r\n    gl_Position = uProjectionMatrix * vec4(aPosition, 0.0, 1.0);\r\n    // vertex e\r\n    vColor = aColor;\r\n    vRegion = aRegion;\r\n}\r\n";const b=(t,e,i)=>{const r=t.createShader(i);if(!r)throw new Error("Unable to create webgl shader");t.shaderSource(r,e),t.compileShader(r);if(!t.getShaderParameter(r,t.COMPILE_STATUS)){const i=t.getShaderInfoLog(r);throw console.error("Shader compilation failed:",i),new Error("Unable to compile shader: "+i+e)}return r};function w(t,e,i,r=!1,s=!1,a="clamp"){const n=t.createTexture();if(!n)throw new Error("unable to create texture");let h;switch(t.bindTexture(t.TEXTURE_2D,n),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,i?t.LINEAR:t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,i?t.LINEAR:t.NEAREST),a){case"repeat":h=t.REPEAT;break;case"mirror":h=t.MIRRORED_REPEAT;break;default:h=t.CLAMP_TO_EDGE}return t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,h),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,h),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,s),r?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e.width,e.height,0,t.RGBA,t.UNSIGNED_BYTE,null):t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),n}const v=5126;var S="precision mediump float;\r\nuniform sampler2D uTextures[%TEXTURE_NUM%];\r\n\r\nvarying vec2 vRegion;\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void) {\r\n    vec4 color;\r\n    %GET_COLOR%\r\n    // fragment\r\n    gl_FragColor = color * vColor;\r\n}",A="precision mediump float;\r\n\r\nattribute vec2 aPosition;\r\nattribute vec2 aRegion;\r\nattribute float aTextureId;\r\nattribute vec4 aColor;\r\n\r\nuniform mat4 uProjectionMatrix;\r\n\r\nvarying vec2 vRegion;\r\nvarying float vTextureId;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void) {\r\n    vRegion = aRegion;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor;\r\n\r\n    // vertex s\r\n    gl_Position = uProjectionMatrix * vec4(aPosition, 0.0, 1.0);\r\n    // vertex e\r\n}";const M=[{name:"aPosition",size:2,type:v,stride:24},{name:"aRegion",size:2,type:v,stride:24,offset:2*Float32Array.BYTES_PER_ELEMENT},{name:"aTextureId",size:1,type:v,stride:24,offset:4*Float32Array.BYTES_PER_ELEMENT},{name:"aColor",size:4,type:5121,stride:24,offset:5*Float32Array.BYTES_PER_ELEMENT,normalized:!0}],U=[{name:"aPosition",size:2,type:v,stride:20},{name:"aColor",size:4,type:5121,stride:20,offset:2*Float32Array.BYTES_PER_ELEMENT,normalized:!0},{name:"aRegion",size:2,type:v,stride:20,offset:3*Float32Array.BYTES_PER_ELEMENT}];class P{constructor(t,e,i,r,s=0){this.attributeLoc={},this.uniformLoc={},this.textureUnitNum=0,this.attributes=[];const a=function(t,e){if(t.includes("%TEXTURE_NUM%")&&(t=t.replace("%TEXTURE_NUM%",e.toString())),t.includes("%GET_COLOR%")){let i="";for(let t=0;t<e;t++)i+=0==t?`if(vTextureId == ${t}.0)`:t==e-1?"else":`else if(vTextureId == ${t}.0)`,i+=`{color = texture2D(uTextures[${t}], vRegion);}`;t=t.replace("%GET_COLOR%",i)}return t}(i,t.maxTextureUnits-s);this.program=((t,e,i)=>{var r=t.createProgram(),s=b(t,e,35633),a=b(t,i,35632);if(!r)throw new Error("Unable to create program shader");if(t.attachShader(r,s),t.attachShader(r,a),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS)){const e=t.getProgramInfoLog(r);throw new Error("Unable to link shader program: "+e)}return r})(t.gl,e,a),this.gl=t.gl,this.textureUnitNum=s,this.parseShader(e),this.parseShader(a),r&&this.setAttributes(r)}setUniforms(t,e){const i=this.gl;for(const r of t.getUnifromNames()){const s=this.getUniform(r);t.bind(i,r,s,e)}}getUniform(t){return this.uniformLoc[t]}use(){this.gl.useProgram(this.program)}parseShader(t){const e=this.gl,i=t.match(/attribute\s+\w+\s+(\w+)/g);if(i)for(const t of i){const i=t.split(" ")[2],r=e.getAttribLocation(this.program,i);-1!=r&&(this.attributeLoc[i]=r)}const r=t.match(/uniform\s+\w+\s+(\w+)/g);if(r)for(const t of r){const i=t.split(" ")[2];this.uniformLoc[i]=e.getUniformLocation(this.program,i)}}setAttribute(t){const e=this.attributeLoc[t.name];if(void 0!==e){const i=this.gl;i.vertexAttribPointer(e,t.size,t.type,t.normalized||!1,t.stride,t.offset||0),i.enableVertexAttribArray(e)}}setAttributes(t){this.attributes=t;for(const e of t)this.setAttribute(e)}updateAttributes(){this.setAttributes(this.attributes)}static createCostumShader(t,e,i,r,s=0){let n={[a.SPRITE]:S,[a.GRAPHIC]:E}[r],h={[a.SPRITE]:A,[a.GRAPHIC]:R}[r];const o={[a.SPRITE]:M,[a.GRAPHIC]:U}[r];return n=n.replace("void main(void) {",i+"\nvoid main(void) {"),h=h.replace("void main(void) {",e+"\nvoid main(void) {"),n=n.replace("// fragment","fragment(color);"),h=h.replace(/\/\/ vertex s[\s\S]*?\/\/ vertex e/,"vec2 position = aPosition;\n            vertex(position, vRegion);\n            gl_Position = uProjectionMatrix * vec4(position, 0.0, 1.0);"),new P(t,h,n,o,s)}}class C{constructor(t){this.usedTextures=[],this.shaders=new Map,this.isCostumShader=!1,this.freeTextureUnitNum=0,this.rapid=t,this.gl=t.gl,this.webglArrayBuffer=new u(t.gl,o.Float32,t.gl.ARRAY_BUFFER,t.gl.STREAM_DRAW),this.maxTextureUnits=t.maxTextureUnits}getTextureUnitList(){return Array.from({length:this.maxTextureUnits},((t,e)=>e))}addVertex(t,e,...i){const[r,s]=this.rapid.matrixStack.apply(t,e);this.webglArrayBuffer.pushFloat32(r),this.webglArrayBuffer.pushFloat32(s)}useTexture(t){const e=this.usedTextures.indexOf(t);return-1==e?(this.usedTextures.push(t),this.freeTextureUnitNum=this.maxTextureUnits-this.usedTextures.length,[this.usedTextures.length-1,!0]):[e,!1]}enterRegion(t){this.currentShader=t??this.getShader("default"),this.currentShader.use(),this.initializeForNextRender(),this.webglArrayBuffer.bindBuffer(),this.currentShader.updateAttributes(),this.updateProjection(),this.isCostumShader=Boolean(t)}updateProjection(){this.gl.uniformMatrix4fv(this.currentShader.uniformLoc.uProjectionMatrix,!1,this.rapid.projection)}isUnifromChanged(t){return!!t&&(this.costumUnifrom!=t||!!t?.isDirty)}setCurrentUniform(t){t.clearDirty(),this.costumUnifrom=t}exitRegion(){}initDefaultShader(t,e,i){this.setShader("default",t,e,i)}setShader(t,e,i,r){this.webglArrayBuffer.bindBuffer(),this.shaders.set(t,new P(this.rapid,e,i,r)),"default"===t&&(this.defaultShader=this.shaders.get(t))}getShader(t){return this.shaders.get(t)}render(){this.executeRender(),this.initializeForNextRender()}executeRender(){const t=this.gl;for(let e=0;e<this.usedTextures.length;e++)t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,this.usedTextures[e]);this.webglArrayBuffer.bufferData()}initializeForNextRender(){this.webglArrayBuffer.clear(),this.usedTextures.length=0,this.isCostumShader=!1,this.freeTextureUnitNum=this.maxTextureUnits}hasPendingContent(){return!1}isShaderChanged(t){return(t||this.defaultShader)!=this.currentShader}}class F extends C{constructor(t){super(t),this.vertex=0,this.offset=f.ZERO,this.drawType=t.gl.TRIANGLE_FAN,this.setShader("default",R,E,U)}startRender(t,e,i,r){r&&this.currentShader?.setUniforms(r,this),this.offset=new f(t,e),this.vertex=0,this.webglArrayBuffer.clear(),i&&i.base&&(this.texture=this.useTexture(i.base.texture)[0])}addVertex(t,e,i,r,s){this.webglArrayBuffer.resize(3),super.addVertex(t+this.offset.x,e+this.offset.y),this.webglArrayBuffer.pushUint32(s),this.webglArrayBuffer.pushFloat32(i),this.webglArrayBuffer.pushFloat32(r),this.vertex+=1}executeRender(){super.executeRender();const t=this.gl;t.uniform1i(this.currentShader.uniformLoc.uUseTexture,void 0===this.texture?0:1),this.texture&&t.uniform1i(this.currentShader.uniformLoc.uTexture,this.texture),t.drawArrays(this.drawType,0,this.vertex),this.drawType=this.rapid.gl.TRIANGLE_FAN,this.vertex=0,this.texture=void 0}}const _=Math.floor(16384);class N extends d{constructor(t,e){super(t,6,4,e)}addObject(t){super.addObject(),this.pushUint16(t),this.pushUint16(t+1),this.pushUint16(t+2),this.pushUint16(t),this.pushUint16(t+3),this.pushUint16(t+2)}}class I extends C{constructor(t){const e=t.gl;super(t),this.batchSprite=0,this.spriteTextureUnits=[],this.spriteTextureUnitIndexOffset=0,this.setShader("default",A,S,M),this.indexBuffer=new N(e,_)}addVertex(t,e,i,r,s,a){super.addVertex(t,e),this.webglArrayBuffer.pushFloat32(i),this.webglArrayBuffer.pushFloat32(r),this.webglArrayBuffer.pushFloat32(s),this.webglArrayBuffer.pushUint32(a)}renderSprite(t,e,i,r,s,a,n,h,o,l,u,c,d,p=0){(1+p>this.freeTextureUnitNum||this.batchSprite>=_||this.isUnifromChanged(u)||this.rapid.projectionDirty)&&(this.render(),u&&this.isUnifromChanged(u)&&(this.currentShader.setUniforms(u,this),this.setCurrentUniform(u)),this.rapid.projectionDirty&&this.updateProjection()),this.batchSprite++,this.webglArrayBuffer.resize(20);const[f,m]=this.useTexture(t);m&&(this.spriteTextureUnits.push(f),this.spriteTextureUnitIndexOffset=this.spriteTextureUnits[0]);const g=f-this.spriteTextureUnitIndexOffset,x=c?a:r,y=c?r:a,T=d?n:s,E=d?s:n,R=h,b=h+e,w=o,v=o+i;this.addVertex(R,w,x,T,g,l),this.addVertex(b,w,y,T,g,l),this.addVertex(b,v,y,E,g,l),this.addVertex(R,v,x,E,g,l)}executeRender(){if(super.executeRender(),this.batchSprite<=0)return;const t=this.gl;this.spriteTextureUnits.length>0&&this.gl.uniform1iv(this.currentShader.uniformLoc.uTextures,this.spriteTextureUnits),t.drawElements(t.TRIANGLES,6*this.batchSprite,t.UNSIGNED_SHORT,0)}enterRegion(t){super.enterRegion(t),this.indexBuffer.bindBuffer()}initializeForNextRender(){super.initializeForNextRender(),this.batchSprite=0,this.spriteTextureUnits.length=0}hasPendingContent(){return this.batchSprite>0}}class B{constructor(t,e){this.cache=new Map,this.render=t,this.antialias=e}async textureFromUrl(t,e=this.antialias,r=i.CLAMP){let s=this.cache.get(t);if(!s){const i=await this.loadImage(t);s=D.fromImageSource(this.render,i,e,r),this.cache.set(t,s)}return new L(s)}textureFromFrameBufferObject(t){return new L(t)}async textureFromSource(t,e=this.antialias,r=i.CLAMP){let s=this.cache.get(t);return s||(s=D.fromImageSource(this.render,t,e,r),this.cache.set(t,s)),new L(s)}async loadImage(t){return new Promise((e=>{const i=new Image;i.onload=()=>{e(i)},i.src=t}))}createText(t){return new k(this.render,t)}destroy(t){t instanceof L?(t.base?.destroy(this.render.gl),this.removeCache(t)):(t.destroy(this.render.gl),this.removeCache(t))}createFrameBufferObject(t,e,i=this.antialias){return new G(this.render,t,e,i)}removeCache(t){const e=t instanceof L?t.base?.texture:t.texture;e&&this.cache.forEach(((t,i)=>{t===e&&this.cache.delete(i)}))}}class D{constructor(t,e,r,s=i.CLAMP){this.texture=t,this.width=e,this.height=r,this.wrapMode=s}static fromImageSource(t,e,r=!1,s=i.CLAMP){return new D(w(t.gl,e,r,!1,!1,s),e.width,e.height)}destroy(t){t.deleteTexture(this.texture)}}class L{constructor(t){this.scale=1,this.setBaseTextur(t)}setBaseTextur(t){t&&(this.base=t,this.setClipRegion(0,0,t.width,t.height))}setClipRegion(t,e,i,r){if(this.base)return this.clipX=t/this.base.width,this.clipY=e/this.base.height,this.clipW=this.clipX+i/this.base.width,this.clipH=this.clipY+r/this.base.height,this.width=i*this.scale,this.height=r*this.scale,this}static fromImageSource(t,e,i=!1){return new L(D.fromImageSource(t,e,i))}static fromUrl(t,e){return t.textures.textureFromUrl(e)}createSpritesHeet(t,e){if(!this.base)return[];const i=[],r=Math.floor(this.base.width/t),s=Math.floor(this.base.height/e);for(let a=0;a<s;a++)for(let s=0;s<r;s++){const r=this.clone();r.setClipRegion(s*t,a*e,t,e),i.push(r)}return i}clone(){return new L(this.base)}}const O=2;class k extends L{constructor(t,e){super(),this.scale=.5,this.rapid=t,this.options=e,this.text=e.text||" ",this.updateTextImage()}updateTextImage(){const t=this.createTextCanvas();this.setBaseTextur(D.fromImageSource(this.rapid,t,!0))}createTextCanvas(){const t=document.createElement("canvas"),e=t.getContext("2d");if(!e)throw new Error("Failed to get canvas context");e.font=`${this.options.fontSize||16}px ${this.options.fontFamily||"Arial"}`,e.fillStyle=this.options.color||"#000",e.textAlign=this.options.textAlign||"left",e.textBaseline=this.options.textBaseline||"top";const i=this.text.split("\n");let r=0,s=0;for(const t of i){const i=e.measureText(t);r=Math.max(r,i.width),s+=this.options.fontSize||16}t.width=2*r,t.height=2*s,e.scale(2,2),e.font=`${this.options.fontSize||16}px ${this.options.fontFamily||"Arial"}`,e.fillStyle=this.options.color||"#000",e.textAlign=this.options.textAlign||"left",e.textBaseline=this.options.textBaseline||"top";let a=0;for(const t of i)e.fillText(t,0,a),a+=this.options.fontSize||16;return t}setText(t){this.text!=t&&(this.text=t,this.updateTextImage())}}class G extends D{constructor(t,e,i,r=!1){const s=t.gl,a=w(s,{width:e,height:i},r,!0,!1),n=s.createFramebuffer();if(!n)throw s.deleteTexture(a),new Error("Failed to create WebGL framebuffer");s.bindFramebuffer(s.FRAMEBUFFER,n),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,a,0);const h=s.createRenderbuffer();if(!h)throw s.deleteFramebuffer(n),s.deleteTexture(a),new Error("Failed to create depth-stencil renderbuffer");s.bindRenderbuffer(s.RENDERBUFFER,h),s.renderbufferStorage(s.RENDERBUFFER,s.STENCIL_INDEX8,e,i),s.framebufferRenderbuffer(s.FRAMEBUFFER,s.STENCIL_ATTACHMENT,s.RENDERBUFFER,h),super(a,e,i),this.gl=s,this.framebuffer=n,s.bindTexture(s.TEXTURE_2D,null),s.bindFramebuffer(s.FRAMEBUFFER,null)}bind(){const t=this.gl;t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.clearColor(.5,.2,.5,.5),t.clear(t.COLOR_BUFFER_BIT)}unbind(){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}resize(t,e){this.width=t,this.height=e,this.gl.bindTexture(this.gl.TEXTURE_2D,this.texture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,t,e,0,this.gl.RGBA,this.gl.UNSIGNED_BYTE,null),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}destroy(t){t.deleteFramebuffer(this.framebuffer),super.destroy(t)}}const z=new Set;class X{constructor(t,e){this.textures=new Map,this.width=t,this.height=e}setTile(t,e){e instanceof L&&(e={texture:e}),this.textures.set(t,e)}getTile(t){return this.textures.get(t)}}class j{constructor(t){this.rapid=t}getYSortRow(t,e,i){if(!t)return[];const r=[];for(const i of t){const t=Math.floor(i.ySort/e);r[t]||(r[t]=[]),r[t].push(i)}return r}getOffset(t){let e=(t.errorX??2)+1,i=(t.errorY??2)+1;if("number"==typeof t.error){const r=(t.error??2)+1;e=r,i=r}else t.error&&(e=t.error.x+1,i=t.error.y+1);return{errorX:e,errorY:i}}getTileData(t,e){const i=e.shape??s.SQUARE,r=t.width,a=i===s.ISOMETRIC?t.height/2:t.height,n=this.rapid.matrixStack,h=n.globalToLocal(f.ZERO),o=n.getGlobalScale(),{errorX:l,errorY:u}=this.getOffset(e),c=Math.ceil(this.rapid.width/r/o.x)+2*l,d=Math.ceil(this.rapid.height/a/o.y)+2*u,p=new f(h.x<0?Math.ceil(h.x/r):Math.floor(h.x/r),h.y<0?Math.ceil(h.y/a):Math.floor(h.y/a));p.x-=l,p.y-=u;let m=new f(0-h.x%r-l*r,0-h.y%a-u*a);return m=m.add(h),{startTile:p,offset:m,viewportWidth:c,viewportHeight:d,height:a,width:r,shape:i}}renderYSortRow(t,e){for(const i of e)i.render?i.render():i.renderSprite&&t.renderSprite(i.renderSprite)}renderLayer(t,e){this.rapid.matrixStack.applyTransform(e);const i=e.tileSet,{startTile:r,offset:a,viewportWidth:n,viewportHeight:h,shape:o,width:l,height:u}=this.getTileData(i,e),c=this.getYSortRow(e.ySortCallback,u,h),d=e.ySortCallback&&e.ySortCallback.length>0;var p;0!==this.rapid.matrixStack.getGlobalRotation()&&(p="TileMapRender: tilemap is not supported rotation",z.has(p)||(z.add(p),console.warn(p)),this.rapid.matrixStack.setGlobalRotation(0));for(let p=0;p<h;p++){const h=p+r.y,f=c[h]??[];if(h<0||h>=t.length)this.renderYSortRow(this.rapid,f);else{for(let c=0;c<n;c++){const n=c+r.x;if(n<0||n>=t[h].length)continue;const d=t[h][n],m=i.getTile(d);if(!m)continue;let g=c*l+a.x,x=p*u+a.y,y=p*u+a.y+(m.ySortOffset??0);h%2!=0&&o===s.ISOMETRIC&&(g+=l/2);const T=e.eachTile&&e.eachTile(d,n,h)||{};f.push({ySort:y,renderSprite:{...m,x:g+(m.x||0),y:x+(m.y||0),...T}})}d&&f.sort(((t,e)=>t.ySort-e.ySort)),this.renderYSortRow(this.rapid,f)}}this.rapid.matrixStack.applyTransform(e)}localToMap(t,e){const i=e.tileSet;if(e.shape===s.ISOMETRIC){let e=0,r=0;const s=i.height/2,a=i.width/2;let n=Math.floor(t.y/s);const h=n%2==0;let o=Math.floor(t.x/a);const l=o%2==0,u=t.x%a/a,c=t.y%s/s,d=c<u,p=c<1-u;return h||(n-=1),d&&!l&&h?n-=1:d||!l||h?p&&l&&h?(o-=2,n-=1):p||l||h||(n+=1):(n+=1,o-=2),e=o,r=n,e=Math.floor(o/2),new f(e,r)}return new f(Math.floor(t.x/i.width),Math.floor(t.y/i.height))}mapToLocal(t,e){const i=e.tileSet;if(e.shape===s.ISOMETRIC){let e=new f(t.x*i.width,t.y*i.height/2);return t.y%2!=0&&(e.x+=i.width/2),e}return new f(t.x*i.width,t.y*i.height)}}const Y=!0;class H{constructor(t,e){this.life=0,this.datas={},this.rapid=t,this.options=e,e.texture instanceof L?this.texture=e.texture:e.texture instanceof Array&&e.texture[0]instanceof Array?this.texture=g.pickWeight(e.texture):e.texture instanceof Array&&(this.texture=g.pick(e.texture)),this.maxLife=g.scalarOrRange(e.life,1),this.datas={speed:this.processAttribute(e.animation.speed,0),rotation:this.processAttribute(e.animation.rotation,0),scale:this.processAttribute(e.animation.scale,1),color:this.processAttribute(e.animation.color,p.White),velocity:this.processAttribute(e.animation.velocity,f.ZERO),acceleration:this.processAttribute(e.animation.acceleration,f.ZERO)},this.position=f.ZERO,this.initializePosition()}processAttribute(t,e){if(!t)return{value:e};if("object"==typeof(i=t)&&null!==i&&Object.getPrototypeOf(i)===Object.prototype){const i=g.scalarOrRange(t.start,e),r=g.scalarOrRange(t.end||i,e);return{delta:t.delta??this.getDelta(i,r,this.maxLife),value:i,damping:t.damping}}return this.processAttribute({start:t},e);var i}updateDamping(t){for(const e of Object.values(this.datas))if(e.damping){const i=e.value,r=Math.pow(e.damping,t);e.value="number"==typeof i?i*r:i.multiply(r)}}updateDelta(t){const e=this.datas;for(const e of Object.values(this.datas))if(e.delta){const i=e.value;"number"==typeof i?e.value+=t*e.delta:e.value=i.add(e.delta.multiply(t))}e.color.value.clamp();const i=f.fromAngle(e.rotation.value).multiply(e.speed.value*t);this.position=this.position.add(i).add(e.velocity.value.multiply(t)).add(e.acceleration.value.multiply(t))}getDelta(t,e,i){return"number"==typeof t&&"number"==typeof e?(e-t)/i:t instanceof f&&e instanceof f||t instanceof p&&e instanceof p?e.subtract(t).divide(i):t}update(t){return this.life+=t,!(this.life>=this.maxLife)&&(this.updateDamping(t),this.updateDelta(t),!0)}render(){this.rapid.renderSprite({...this.options,position:this.position,scale:this.datas.scale.value,rotation:this.datas.rotation.value,color:this.datas.color.value,texture:this.texture})}initializePosition(){switch(this.options.emitShape){case h.POINT:this.position=f.ZERO;break;case h.CIRCLE:const t=Math.random()*Math.PI*2,e=(this.options.emitRadius||0)*Math.sqrt(Math.random());this.position=new f(Math.cos(t)*e,Math.sin(t)*e);break;case h.RECT:this.position=new f((Math.random()-.5)*(this.options.emitRect?.width||0),(Math.random()-.5)*(this.options.emitRect?.height||0))}!this.options.localSpace&&this.options.position&&(this.position=this.position.add(this.options.position))}}class W{constructor(t,e){this.particles=[],this.emitting=!1,this.emitTimer=0,this.emitRate=10,this.emitTime=0,this.emitTimeCounter=0,this.localSpace=Y,this.position=f.ZERO,this.rapid=t,this.options=e,this.emitRate=void 0!==e.emitRate?e.emitRate:10,this.emitTime=void 0!==e.emitTime?e.emitTime:0,this.localSpace=void 0!==e.localSpace?e.localSpace:Y,this.position=e.position||f.ZERO}getTransform(){return this.options}setEmitRate(t){this.emitRate=t}setEmitTime(t){this.emitTime=t}start(){this.emitting=!0,this.emitTimeCounter=0}stop(){this.emitting=!1}clear(){this.particles=[],this.emitTimeCounter=0}emit(t){const e=Math.min(t,(this.options.maxParticles||1/0)-this.particles.length);for(let t=0;t<e;t++){const t={...this.options},e=new H(this.rapid,t);this.particles.unshift(e)}}update(t){if(this.emitting&&this.emitRate>0)if(this.emitTime>0){if(this.emitTimeCounter+=t,this.emitTimeCounter>=this.emitTime){const t=Math.floor(this.emitTimeCounter/this.emitTime);this.emit(this.emitRate*t),this.emitTimeCounter-=t*this.emitTime}}else{this.emitTimer+=t;const e=this.emitRate*t,i=Math.floor(e);i>0&&(this.emit(i),this.emitTimer-=i/this.emitRate);this.emitTimer*this.emitRate>=1&&(this.emit(1),this.emitTimer-=1/this.emitRate)}for(let e=this.particles.length-1;e>=0;e--)this.particles[e].update(t)||this.particles.splice(e,1)}render(){for(const t of this.particles)t.render()}getParticleCount(){return this.particles.length}isActive(){return this.emitting||this.particles.length>0}oneShot(){this.emit(this.emitRate)}}class q{constructor(e){this.projectionDirty=!0,this.matrixStack=new c,this.tileMap=new j(this),this.light=new x(this),this.defaultColor=new p(255,255,255,255),this.regions=new Map,this.currentMaskType=[],this.currentTransform=[],this.currentFBO=[],this.lastTime=0;const i=(t=>{const e={stencil:!0},i=t.getContext("webgl2",e)||t.getContext("webgl",e);if(!i)throw new Error("Unable to initialize WebGL. Your browser may not support it.");return i})(e.canvas);this.gl=i,this.canvas=e.canvas,this.textures=new B(this,e.antialias??!1),this.maxTextureUnits=i.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.width=e.width||this.canvas.width,this.height=e.height||this.canvas.height,this.scaleEnable=e.scaleEnable??!1,this.scaleRadio=e.scaleRadio||t.KEEP,this.devicePixelRatio=e.devicePixelRatio??window.devicePixelRatio??1,this.backgroundColor=e.backgroundColor||new p(255,255,255,255),this.registerBuildInRegion(),this.initWebgl(i),this.updateDisplaySize(this.width,this.height),this.projectionDirty=!1,this.canvas.style.display="block"}updateDisplaySize(e,i){const r=this.width,s=this.height;let a,n,h,o;if(this.scaleEnable){const l=r/s,u=e/i;switch(this.scaleRadio){case t.IGNORE:a=r,n=s,h=e*this.devicePixelRatio,o=i*this.devicePixelRatio;break;case t.KEEP:let c,d;a=r,n=s,u>l?(d=i,c=d*l):(c=e,d=c/l),h=c*this.devicePixelRatio,o=d*this.devicePixelRatio;break;case t.EXPAND:u>l?(n=s,a=s*u):(a=r,n=r/u),h=e*this.devicePixelRatio,o=i*this.devicePixelRatio;break;case t.KEEP_W:a=r,n=r/u,h=e*this.devicePixelRatio,o=i*this.devicePixelRatio;break;case t.KEEP_H:n=s,a=s*u,h=e*this.devicePixelRatio,o=i*this.devicePixelRatio;break;default:a=r,n=s,h=e*this.devicePixelRatio,o=i*this.devicePixelRatio}}else a=r,n=s,h=r*this.devicePixelRatio,o=s*this.devicePixelRatio;this.logicWidth=a,this.logicHeight=n,this.physicsWidth=h,this.physicsHeight=o,this.resizeSize(a,n,h,o,!0)}resizeSize(t,e,i,r,s=!1){this.updateProjection(0,t,e,0),this.gl.viewport(0,0,i,r),this.gl.scissor(0,0,i,r),s&&(this.canvas.width=i,this.canvas.height=r,this.canvas.style.width=i/this.devicePixelRatio+"px",this.canvas.style.height=r/this.devicePixelRatio+"px")}updateProjection(t,e,i,r){this.projection=this.createOrthMatrix(t,e,i,r),this.projectionDirty=!0}initWebgl(t){t.enable(t.BLEND),t.disable(t.DEPTH_TEST),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),t.enable(t.STENCIL_TEST),t.enable(t.SCISSOR_TEST)}clearTextureUnit(){for(let t=0;t<this.maxTextureUnits;t++)this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,null)}registerBuildInRegion(){this.registerRegion("sprite",I),this.registerRegion("graphic",F)}registerRegion(t,e){this.regions.set(t,new e(this))}quitCurrentRegion(){this.currentRegion&&this.currentRegion.hasPendingContent()&&(this.currentRegion.render(),this.currentRegion.exitRegion())}setRegion(t,e){if(t!=this.currentRegionName||this.currentRegion&&this.currentRegion.isShaderChanged(e)){const i=this.regions.get(t);this.quitCurrentRegion(),this.currentRegion=i,this.currentRegionName=t,i.enterRegion(e)}}save(){this.matrixStack.pushMat()}restore(){this.matrixStack.popMat()}withTransform(t){this.save(),t(),this.restore()}startRender(t=!0){this.clear(),t&&this.matrixStack.clear(),this.matrixStack.pushIdentity(),this.currentRegion=void 0,this.currentRegionName=void 0;const e=performance.now(),i=this.lastTime?(e-this.lastTime)/1e3:0;return this.lastTime=e,i}endRender(){this.currentRegion?.render(),this.projectionDirty=!1}render(t){t(this.startRender()),this.endRender()}renderTileMapLayer(t,e){this.tileMap.renderLayer(t,e instanceof X?{tileSet:e}:e)}applyCameraTransform(t){this.matrixStack.applyTransform(t),this.matrixStack.setTransform(this.matrixStack.getInverse())}renderSprite(t){const e=t.texture;if(!e||!e.base)return;const{offsetX:i,offsetY:r}=this.startDraw(t,e.width,e.height);this.setRegion("sprite",t.shader),this.currentRegion.renderSprite(e.base.texture,e.width,e.height,e.clipX,e.clipY,e.clipW,e.clipH,i,r,(t.color||this.defaultColor).uint32,t.uniforms,t.flipX,t.flipY),this.afterDraw()}renderParticles(t){t.localSpace?(this.startDraw(t.getTransform()),t.render(),this.afterDraw()):t.render()}renderTexture(t){t.base&&this.renderSprite({texture:t})}renderLine(t){const e=t.closed?[...t.points,t.points[0]]:t.points,{vertices:i,uv:r}=T({...t,points:e});this.renderGraphic({...t,drawType:this.gl.TRIANGLES,points:i,uv:r})}renderGraphic(t){this.startGraphicDraw(t),t.points.forEach(((e,i)=>{const r=Array.isArray(t.color)?t.color[i]:t.color,s=t.uv?.[i];this.addGraphicVertex(e.x,e.y,s,r)})),this.endGraphicDraw()}startGraphicDraw(t){const{offsetX:e,offsetY:i}=this.startDraw(t);this.setRegion("graphic",t.shader);const r=this.currentRegion;r.startRender(e,i,t.texture,t.uniforms),t.drawType&&(r.drawType=t.drawType)}addGraphicVertex(t,e,i,r){this.currentRegion.addVertex(t,e,i?.x,i?.y,(r||this.defaultColor).uint32)}endGraphicDraw(){this.currentRegion.render(),this.afterDraw()}startDraw(t,e=0,i=0){return this.currentTransform.push(t),this.matrixStack.applyTransform(t,e,i)}afterDraw(){this.currentTransform.length>0&&this.matrixStack.applyTransformAfter(this.currentTransform.pop())}renderRect(t){const{width:e,height:i}=t,r=[new f(0,0),new f(e,0),new f(e,i),new f(0,i)];this.renderGraphic({...t,points:r,drawType:this.gl.TRIANGLE_FAN})}renderCircle(t){const e=t.segments||32,i=t.radius,r=t.color||this.defaultColor,s=[];for(let t=0;t<=e;t++){const r=t/e*Math.PI*2,a=Math.cos(r)*i,n=Math.sin(r)*i;s.push(new f(a,n))}this.renderGraphic({...t,points:s,color:r,drawType:this.gl.TRIANGLE_FAN})}clear(t){const e=this.gl,i=t||this.backgroundColor;e.clearColor(i.r/255,i.g/255,i.b/255,i.a/255),e.clear(e.COLOR_BUFFER_BIT),this.clearMask()}createOrthMatrix(t,e,i,r){return new Float32Array([2/(e-t),0,0,0,0,2/(r-i),0,0,0,0,-1,0,-(e+t)/(e-t),-(r+i)/(r-i),0,1])}drawMask(t=r.Include,e){this.startDrawMask(t),e(),this.endDrawMask()}startDrawMask(t=r.Include){const e=this.gl;this.currentMaskType.push(t),this.setMaskType(t,!0),e.stencilOp(e.KEEP,e.KEEP,e.REPLACE),e.colorMask(!1,!1,!1,!1)}endDrawMask(){const t=this.gl;this.quitCurrentRegion(),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.colorMask(!0,!0,!0,!0),this.setMaskType(this.currentMaskType.pop()??r.Include,!1)}setMaskType(t,e=!1){const i=this.gl;if(this.quitCurrentRegion(),e)this.clearMask(),i.stencilFunc(i.ALWAYS,1,255);else switch(t){case r.Include:i.stencilFunc(i.EQUAL,1,255);break;case r.Exclude:i.stencilFunc(i.NOTEQUAL,1,255)}}clearMask(){const t=this.gl;this.quitCurrentRegion(),t.clearStencil(0),t.clear(t.STENCIL_BUFFER_BIT),t.stencilFunc(t.ALWAYS,1,255)}createCostumShader(t,e,i,r=0){return P.createCostumShader(this,t,e,i,r)}startFBO(t){this.quitCurrentRegion(),t.bind(),this.clearTextureUnit(),this.resizeSize(t.width,t.height,t.width,t.height),this.updateProjection(0,t.width,0,t.height),this.save(),this.matrixStack.identity(),this.currentFBO.push(t)}endFBO(){if(this.currentFBO.length>0){const t=this.currentFBO.pop();this.quitCurrentRegion(),t.unbind(),this.clearTextureUnit(),this.resizeSize(this.logicWidth,this.logicHeight,this.physicsWidth,this.physicsHeight),this.restore()}}drawToFBO(t,e){this.startFBO(t),e(),this.endFBO()}setBlendMode(t){switch(t){case n.Additive:this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE);break;case n.Subtractive:this.gl.blendFunc(this.gl.ZERO,this.gl.ONE_MINUS_SRC_COLOR);break;case n.Mix:this.gl.blendFunc(this.gl.SRC_ALPHA,this.gl.ONE_MINUS_SRC_ALPHA)}}drawLightShadowMask(t){this.startDrawMask(t.type||r.Exclude);this.light.createLightShadowMaskPolygon(t.occlusion,t.lightSource,t.baseProjectionLength).forEach((t=>{this.renderGraphic({points:t,color:p.Black})})),this.endDrawMask()}createParticleEmitter(t){return new W(this,t)}}class ${constructor(t){this.isDirty=!1,this.data=t}setUniform(t,e){this.data[t]!=e&&(this.isDirty=!0),this.data[t]=e}clearDirty(){this.isDirty=!1}getUnifromNames(){return Object.keys(this.data)}bind(t,e,i,r){if(!i)return;const s=this.data[e];if("number"==typeof s)t.uniform1f(i,s);else if(Array.isArray(s))switch(s.length){case 1:Number.isInteger(s[0])?t.uniform1i(i,s[0]):t.uniform1f(i,s[0]);break;case 2:Number.isInteger(s[0])?t.uniform2iv(i,s):t.uniform2fv(i,s);break;case 3:Number.isInteger(s[0])?t.uniform3iv(i,s):t.uniform3fv(i,s);break;case 4:Number.isInteger(s[0])?t.uniform4iv(i,s):t.uniform4fv(i,s);break;case 9:t.uniformMatrix3fv(i,!1,s);break;case 16:t.uniformMatrix4fv(i,!1,s);break;default:console.error(`Unsupported uniform array length for ${e}:`,s.length)}else if("boolean"==typeof s)t.uniform1i(i,s?1:0);else if(s.base?.texture){const e=r.useTexture(s.base.texture)[0];t.uniform1i(i,e)}else console.error(`Unsupported uniform type for ${e}:`,typeof s)}}export{o as ArrayType,D as BaseTexture,n as BlendMode,p as Color,l as DynamicArrayBuffer,G as FrameBufferObject,P as GLShader,e as LineTextureMode,r as MaskType,m as MathUtils,c as MatrixStack,W as ParticleEmitter,h as ParticleShape,g as Random,q as Rapid,O as SCALEFACTOR,t as ScaleRadio,a as ShaderType,k as Text,L as Texture,B as TextureCache,i as TextureWrapMode,j as TileMapRender,X as TileSet,s as TilemapShape,$ as Uniform,f as Vec2,u as WebglBufferArray,d as WebglElementBufferArray,U as graphicAttributes,M as spriteAttributes};
